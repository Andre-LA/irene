-- Lunar Lander simple game

--[[
  Copyright (c) 2020-2022 Andr√© Luiz Alvares

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at https://mozilla.org/MPL/2.0/.

  SPDX-License-Identifier: MPL-2.0
]]

-- nene
local Nene = require 'nene'
local Color = require 'nene.color'
local Scancode = require 'nene.scancode'
local AnimationRange = require 'nene.animation'
local Font = require 'nene.font'
local Texture = require 'nene.texture'
local TextTexture = require 'nene.text_texture'
local Tilemap = require 'nene.tilemap'

local Music = require 'nene.audio.music'
local Sound = require 'nene.audio.sound'

local Vec2 = require 'nene.math.vec2'
local Rect = require 'nene.math.rect'
local Grid = require 'nene.math.grid'

-- rotor
local entity = require 'rotor.entity'
local component = require 'rotor.component'
local system = require 'rotor.system'
local storage = require 'rotor.storage'
local GenIdx = require 'rotor.gen_idx'

-- irene
local Position = require 'irene.components.position'
local Collider = require 'irene.components.collider'
local Velocity = require 'irene.components.velocity'
local Gravity = require 'irene.components.gravity'
local EntityData = require 'irene.components.entity_data'
local Sprite = require 'irene.components.sprite'
local Camera = require 'irene.components.camera'
local TilemapComp = require 'irene.components.tilemap'

local GravitySystem = require 'irene.systems.gravity_system'
local CollisionSystem = require 'irene.systems.collision_system'
local VelocitySystem = require 'irene.systems.velocity_system'
local SpriteAnimation = require 'irene.systems.sprite_animation'
local SpritePainterSystem = require 'irene.systems.sprite_painter_system'
local TilemapPainter = require 'irene.systems.tilemap_painter'
local CameraSystem = require 'irene.systems.camera_system'
local PositionHierarchySystem = require 'irene.systems.position_hierarchy'
local InterruptVelocityByCollisionSystem = require 'irene.systems.interrupt_velocity_by_collision_system'

## local textmap = require 'irene.utils.textmap'
## local map_caller = require 'irene.utils.map_caller'

-- nprof
-- NOTE: nprof it's broken broken for now, it'll be fixed later :)
## if PROF then
local nprof = require 'nprof'
## end

## local function prof(title)
  ## if PROF then
    nprof:push(#[title]#)
    defer nprof:pop() end
  ## end
## end

-- main Game records and general variables
local Lander_Start_Position: Vec2 = {}
local LANDER_MAX_VELOCITY <comptime> = 300

local WINDOW_WIDTH <comptime> = 800
local WINDOW_HEIGHT <comptime> = 624

local SCREEN_WIDTH <comptime> = (WINDOW_WIDTH // 2)
local SCREEN_HEIGHT <comptime> = (WINDOW_HEIGHT // 2)

local ok, nene <close> = Nene.init("Lunar lander test", WINDOW_WIDTH, WINDOW_HEIGHT)
assert(ok, 'error: nene initialization failed')

-- Game resources --
local Resources = @record{
  font: Font,

  sprites_and_bg: Texture,

  maps: record{
    map: Tilemap,
    bgmap: Tilemap,
  },

  audio: record{
    music: Music,
    sound_effects: record{
      land: Sound,
      hit: Sound
    }
  },
}

function Resources:unload()
  self.font:destroy()
  self.sprites_and_bg:destroy()

  self.maps.map:destroy()
  self.maps.bgmap:destroy()

  self.audio.sound_effects.land:destroy()
  self.audio.sound_effects.hit:destroy()

  self.audio.music:destroy()
end

local Resources.res: Resources

-- Entity Masks --
local EntityMask = @enum{
  Lander = 0b001,
  Floor  = 0b010,
  Safe   = 0b100,
}

-- animations
local animations: record{
  prop_active: AnimationRange,
  prop_inactive: AnimationRange,
} = {
  prop_active   = { fps = 12, from = 0, to = 1, loop = true, },
  prop_inactive = { fps =  1, from = 4, to = 4, },
}

local LanderState = @enum{
  Flying = 1,
  Landed,
  Crashed,
}

-- components --
local LanderController = @component(@record{
  propulsion_force: number,
  state: LanderState
})

-- entities --
local SafeLanding = @entity(@record{
  position: Position,
  collider: Collider,
  entity_data: EntityData,
})
local SafeLanding.storage: storage(SafeLanding, 11)

function SafeLanding.init(rect: Rect): *SafeLanding
  local ok, id, safe_landing = SafeLanding.storage:push({
    position = {
      local_pos = { rect.x, rect.y },
    },

    collider = {
      hitbox = { 0,0 , rect.w, rect.h },
    },

    entity_data = {
      mask = EntityMask.Safe,
    }
  })
  assert(ok, "Couldn't add a safe landing entity")

  safe_landing.entity_data.id = id

  return safe_landing
end

local Floor = @entity(@record{
  position: Position,
  collider: Collider,
  entity_data: EntityData,
})

local Floor.storage: storage(Floor, 512)

function Floor.init(rect: Rect): *Floor
  local ok, id, floor = Floor.storage:push({
    position = {
      local_pos = { rect.x, rect.y },
    },

    collider = {
      hitbox = { 0,0 , rect.w, rect.h },
    },

    entity_data = {
      mask = EntityMask.Floor,
    },
  })
  assert(ok, "Couldn't add a floor entity")

  floor.entity_data.id = id

  return floor
end

local LanderPropulsion = @entity(@record{
  position: Position,
  sprite: Sprite,
})

function LanderPropulsion.init(): LanderPropulsion
  local propulsion: LanderPropulsion = {
    position = {
      local_pos = { 0, 16 },
    },

    sprite = {
      texture = Resources.res.sprites_and_bg,
      frame_rect = { 0,0 , 16,16 },
      animation_running = true,
      current_animation = animations.prop_inactive,
    },
  }

  return propulsion
end

local CameraEntity = @entity(@record{
  position: Position,
  camera: Camera,
})

local Lander = @entity(@record{
  position: Position,
  sprite: Sprite,
  velocity: Velocity,
  gravity: Gravity,
  collider: Collider,
  entity_data: EntityData,

  controller: LanderController,

  propulsion: LanderPropulsion,
  camera: CameraEntity,
})

local Lander.storage: storage(Lander, 1)

-- collision reaction callbacks
local function on_lander_begin_collision(self: *Collider, other: *Collider, self_data: *EntityData, other_data: *EntityData)
  local ok, lander = Lander.storage:mget(self_data.id)
  assert(ok, "Couldn't find lander")

  switch other_data.mask do
  case EntityMask.Safe then
    lander.controller.state = LanderState.Landed
    Resources.res.audio.sound_effects.land:play()

  case EntityMask.Floor then
    lander.controller.state = LanderState.Crashed
    Resources.res.audio.sound_effects.hit:play()
  end
end

local function on_lander_end_collision(self: *Collider, other: *Collider, self_data: *EntityData, other_data: *EntityData)
  local ok, lander = Lander.storage:mget(self_data.id)
  assert(ok, "Couldn't find lander")

  if other_data.mask  == EntityMask.Safe then
    lander.controller.state = LanderState.Flying
  end
end

function Lander.init(): GenIdx
  local gravity_acceleration <comptime> = 30

  local ok, id, lander = Lander.storage:push({
    position = {
      local_pos = Lander_Start_Position,
    },

    sprite = {
      texture = Resources.res.sprites_and_bg,
      frame_rect = { 64,16, 16,16 },
    },

    velocity = {
      active = true,
      max_velocity = LANDER_MAX_VELOCITY,
      velocity_is_limited = true,
      use_deltatime = true,
    },

    gravity = {
      active = true,
      acceleration = gravity_acceleration,
      direction = { 0, 1 },
    },

    collider = {
      active = true,
      hitbox = { 0,0 , 16,16 },
      collision_mask = EntityMask.Floor | EntityMask.Safe,
      with_collision = true,
      corner_tolerance = 2,
      on_begin_collision = on_lander_begin_collision,
      on_end_collision   = on_lander_end_collision,
    },

    entity_data = {
      mask = EntityMask.Lander,
    },

    controller = {
      propulsion_force = gravity_acceleration * 2.5,
      state = LanderState.Flying,
    },

    propulsion = LanderPropulsion.init(),

    camera = {
      camera = {
        offset = { 7, 5 },
        half_screen_size = { SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 }
      }
    },
  })
  assert(ok, 'could not create lander entity')

  lander.entity_data.id = id

  return id
end

function Lander:reset()
  self.controller.state = LanderState.Flying
  self.position.local_pos = Lander_Start_Position
  self.velocity.final_velocity = {}
end

local LunarMap = @entity(@record{
  position: Position,
  tilemap: TilemapComp,
})

function LunarMap.init(pos: Vec2, tilemap: Tilemap): LunarMap
  local lunarmap: LunarMap = {
    position = {
      local_pos = pos
    },

    tilemap = {
      =tilemap,
      tileset = Resources.res.sprites_and_bg
    },
  }

  return lunarmap
end

-- this function depends on entities, thus it's declared after them
function Resources:load()
  -- audio
  local ok, music = Music.load('tests/lunar-lander/assets/lunar-lander-music.ogg')
  assert(ok, 'Could not load "Lunar Lander" music')
  self.audio.music = music

  local ok, land = Sound.load('tests/lunar-lander/assets/land.wav')
  assert(ok, 'Could not load "land" sound effect')
  self.audio.sound_effects.land = land

  local ok, hit = Sound.load('tests/lunar-lander/assets/hit.wav')
  assert(ok, 'Could not load "hit" sound effect')
  self.audio.sound_effects.hit = hit

  -- texture sprites
  local ok, texture= Texture.load('tests/lunar-lander/assets/figures/sprites.png')
  assert(ok, 'Could not load "sprites" texture')
  self.sprites_and_bg = texture

  -- font
  local ok, font = Font.load('nene/resources/monogram_extended.ttf', 16)
  self.font = font

  do --maps
    local _map: vector(isize) = {}

    ##[[
      local function from_cr_to_pos(column, row) return (column - 1) * 16, (row - 1) * 16 end
      local function from_wh_to_size(w, h) return w * 16, h * 16 end
      local charframe = { f = 6, s = 7 }
      local level_map = require 'tests.lunar-lander.assets.map'
    ]]

    ## local function fn_all(column, row, char)
      _map:push(#[charframe[char] or -1]#)
    ## end

    ## local function set_lander_start_pos (column, row)
      ## local pos_x, pos_y = from_cr_to_pos(column, row)
      Lander_Start_Position = { #[pos_x]# + 2, #[pos_y]# }
    ## end

    ## local function create_floor(rect)
      ## local pos_x, pos_y = from_cr_to_pos(rect.x, rect.y)
      ## local size_x, size_y = from_wh_to_size(rect.w, rect.h)
      Floor.init({ #[pos_x]#, #[pos_y]#, #[size_x]#, #[size_y]# })
    ## end

    ## local function create_safe(rect)
      ## local pos_x, pos_y = from_cr_to_pos(rect.x, rect.y)
      ## local size_x, size_y = from_wh_to_size(rect.w, rect.h)
      SafeLanding.init({ #[pos_x]#, #[pos_y]#, #[size_x]#, #[size_y]# })
    ## end

    ##[[
      local map = textmap.from_text(level_map)
      map_caller(map, fn_all, { L = set_lander_start_pos }, { f = create_floor, s = create_safe })
    ]]

    self.maps.map = {
      tilemap_width = 50,
      tileset_width = 5,
      grid = { cell_size = { 16, 16 } },
      map = _map,
    }

    self.maps.bgmap = {
      tilemap_width = 25,
      tileset_width = 5,
      grid = { cell_size = { 32, 32 } },
      map = {
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
      }
    }
  end
end

-- system --

local LanderControllerSystem = @record{}

function LanderControllerSystem:run(c: record{
  sprite: *Sprite, lander_controller: *LanderController, propulsion: *LanderPropulsion, velocity: *Velocity, gravity: *Gravity
})
  local is_right_down, is_up_down, is_left_down = nene:get_scancode(Scancode.Right),
                                                  nene:get_scancode(Scancode.Up),
                                                  nene:get_scancode(Scancode.Left)

  c.propulsion.sprite:set_animation(is_up_down and animations.prop_active or animations.prop_inactive, nene.current_time)

  if is_right_down or is_up_down or is_left_down then
    local direction: Vec2 = {
      x = (do
        if is_right_down then
          in 1
        elseif is_left_down then
          in -1
        else
          in 0
        end
      end),

      y = is_up_down and -1 or 0
    }

    c.velocity:add_velocity(direction * c.lander_controller.propulsion_force * nene.delta_time)
  end
end

-- Game State --
local GameState = @record{
  -- screen target
  screen: Texture,
  -- entities
  lander_id: GenIdx,
  --maps
  lunarmaps: record{
    map: LunarMap,
    bgmap: LunarMap,
  },
  -- systems
  systems: record{
    lander_ctrl_system: system(LanderControllerSystem.run),

    gravity_system: system(GravitySystem.run),
    velocity_system: system(VelocitySystem.run),
    sprite_animation: system(SpriteAnimation.run),
    sprite_painter: system(SpritePainterSystem.run),
    collision_system: system(CollisionSystem.run),
    tilemap_painter: system(TilemapPainter.run),
    camera_system: system(CameraSystem.run),
    position_hierarchy: system(PositionHierarchySystem.run),
    interrupt_velocity_by_collision_system: system(InterruptVelocityByCollisionSystem.run),
  },
  -- useful data
  last_startmusic_time: float32,
}

function GameState:init()
  local ok, tex_target = Texture.create_texture(SCREEN_WIDTH, SCREEN_HEIGHT, nil, Texture.Access.Target)
  assert(ok, 'Could not create screen texture')
  self.screen = tex_target

  self.lunarmaps.bgmap = LunarMap.init({0,16}, Resources.res.maps.bgmap)
  self.lunarmaps.map =  LunarMap.init({0,0}, Resources.res.maps.map)

  self.lander_id = Lander.init()
end

function GameState:reset()
  local ok, lander = Lander.storage:mget(self.lander_id)
  assert(ok, "Couldn't get lander entity")
  lander:reset()
end

function GameState:unload()
  Music.stop()
  self.screen:destroy()
  self.systems.collision_system.data.collidables:destroy()
end

function GameState:run_system(sysname: string <comptime>, pre_run: facultative(boolean), post_run: facultative(boolean))
  ## prof(sysname.value)

  local system = &self.systems.#|sysname.value|#

  ## if not pre_run.type.is_niltype then
    if pre_run then
      system.data:pre_run()
    end
  ## end

  system:run(
    &self.lunarmaps.bgmap,
    &self.lunarmaps.map,
    &SafeLanding.storage,
    &Floor.storage,
    &Lander.storage
  )

  ## if not post_run.type.is_niltype then
    if post_run then
      system.data:post_run()
    end
  ## end
end

local Game_State: GameState

-- game init --
Resources.res:load()
defer Resources.res:unload() end

Game_State:init()
defer Game_State:unload() end

local landed_txt <close> = TextTexture.init("You Landed!", Resources.res.font)
local crashed_txt <close> = TextTexture.init("You Crashed!", Resources.res.font)
local fps_txt <close> = TextTexture.init("00", Resources.res.font)

-- game functions --
local function paint_dev_info()
  nene:render_draw_line({SCREEN_WIDTH // 2, 0}, {SCREEN_WIDTH // 2, SCREEN_HEIGHT}, Color.Palette.yellow)
  nene:render_draw_line({0, SCREEN_HEIGHT // 2}, {SCREEN_WIDTH, SCREEN_HEIGHT // 2}, Color.Palette.yellow)

  local fps = 1 / nene.delta_time
  local fps_str <close> = (do
    local fps_num_str <close> = tostring(fps)
    local fps_fps_str = 'FPS: ' .. fps_num_str
    in fps_fps_str
  end)

  fps_txt:update_text(fps_str, Resources.res.font)
  fps_txt:draw({8, 8}, Color.Palette.red)
end

local function flying_systems()
  prof!('flying systems')

  Game_State:run_system('gravity_system')
  Game_State:run_system('lander_ctrl_system')

  Game_State:run_system('collision_system', true, true)
  Game_State:run_system('interrupt_velocity_by_collision_system')

  Game_State:run_system('velocity_system')

  Game_State:run_system('position_hierarchy')

  Game_State:run_system('sprite_animation')
end

local function update()
  prof!('processing systems')

  local ok, lander = Lander.storage:mget(Game_State.lander_id)
  assert(ok, "Couldn't get lander entity")

  local is_flying = lander.controller.state == LanderState.Flying
  if is_flying then
    flying_systems()
  end
end

local function painting_systems()
  prof!('painting systems')

  Game_State:run_system('camera_system')
  Game_State:run_system('tilemap_painter')
  Game_State:run_system('sprite_painter')
end

local function draw_stop_flying_text(lander_state: LanderState)
  local tex_txt: TextTexture = lander_state == LanderState.Landed and landed_txt or crashed_txt

  local half_screen: Vec2 = { (SCREEN_WIDTH // 2), (SCREEN_HEIGHT // 2) }
  local half_tex_size: Vec2 = {tex_txt.texture.width // 2, tex_txt.texture.height // 2}

  local draw_pos = half_screen - half_tex_size

  tex_txt:draw(draw_pos + Vec2{1, 1}, Color.Palette.black)
  tex_txt:draw(draw_pos, Color.Palette.white)
end

local function draw()
  prof!('draw')

  local show_dev_info = nene:get_scancode(Scancode.I)

  nene:set_render_target(Game_State.screen:get_raw())
  nene:render_clear(Color.Palette.black)

  painting_systems()

  if show_dev_info then
    Game_State.systems.collision_system.data:draw_hitboxes()
  end

  nene.render_offset = {}

  local ok, lander = Lander.storage:mget(Game_State.lander_id)
  assert(ok, "Couldn't get lander entity")

  local is_flying = lander.controller.state == LanderState.Flying

  if not is_flying then
    draw_stop_flying_text(lander.controller.state)
  end

  if show_dev_info then
    paint_dev_info()
  end

  nene:set_render_target(nilptr)
  Game_State.screen:draw()
end

-- Main Loop --
Resources.res.audio.music:play()

repeat
  nene:poll_events()

  if nene:get_scancode(Scancode.R) then
    Game_State:reset()
  end

  update()
  draw()

  ## if PROF then
    nprof:draw()
    nprof:reset()
  ## end

  nene:render_present()
until nene.quit
