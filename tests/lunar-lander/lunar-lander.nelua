-- Lunar Lander simple game

--[[
  Copyright (c) 2020-2022 Andr√© Luiz Alvares

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at https://mozilla.org/MPL/2.0/.

  SPDX-License-Identifier: MPL-2.0
]]

-- nene
local Nene = require 'nene'
local Color = require 'nene.color'
local Scancode = require 'nene.scancode'
local AnimationRange = require 'nene.animation'
local Font = require 'nene.font'
local Texture = require 'nene.texture'
local TextTexture = require 'nene.text_texture'
local Tilemap = require 'nene.tilemap'

local Music = require 'nene.audio.music'
local Sound = require 'nene.audio.sound'

local Vec2 = require 'nene.math.vec2'
local Rect = require 'nene.math.rect'
local Grid = require 'nene.math.grid'

-- rotor
local entity = require 'rotor.entity'
local component = require 'rotor.component'
local system = require 'rotor.system'
local storage = require 'rotor.storage'
local GenIdx = require 'rotor.gen_idx'
local derived_entity = require 'rotor.derived_entity'
local utils = require 'rotor.utils'

-- irene
local Position = require 'irene.components.position'
local Collider = require 'irene.components.collider'
local Velocity = require 'irene.components.velocity'
local Gravity = require 'irene.components.gravity'
local EntityData = require 'irene.components.entity_data'
local Sprite = require 'irene.components.sprite'
local Camera = require 'irene.components.camera'
local TilemapComp = require 'irene.components.tilemap'

local GravitySystem = require 'irene.systems.gravity_system'
local CollisionSystem = require 'irene.systems.collision_system'
local VelocitySystem = require 'irene.systems.velocity_system'
local SpriteAnimation = require 'irene.systems.sprite_animation'
local SpritePainterSystem = require 'irene.systems.sprite_painter_system'
local TilemapPainter = require 'irene.systems.tilemap_painter'
local CameraSystem = require 'irene.systems.camera_system'
local PositionHierarchySystem = require 'irene.systems.position_hierarchy'
local InterruptVelocityByCollisionSystem = require 'irene.systems.interrupt_velocity_by_collision_system'

local PixelArtCamera = require 'irene.entities.pixelart_camera'

## local textmap = require 'irene.utils.textmap'
## local map_caller = require 'irene.utils.map_caller'

-- nprof
-- NOTE: nprof it's broken broken for now, it'll be fixed later :)
## if PROF then
local nprof = require 'nprof'
## end

## local function prof(title)
  ## if PROF then
    nprof:push(#[title]#)
    defer nprof:pop() end
  ## end
## end

-- main Game records and general variables
local Lander_Start_Position: Vec2 = {}
local LANDER_MAX_VELOCITY <comptime> = 300

local WINDOW_WIDTH <comptime> = 800
local WINDOW_HEIGHT <comptime> = 624

local SCREEN_WIDTH <comptime> = (WINDOW_WIDTH // 2)
local SCREEN_HEIGHT <comptime> = (WINDOW_HEIGHT // 2)

local ok, nene <close> = Nene.init("Lunar lander test", WINDOW_WIDTH, WINDOW_HEIGHT)
assert(ok, 'error: nene initialization failed')

-- Game resources --
local Resources = @record{
  font: Font,

  sprites_and_bg: Texture,

  maps: record{
    map: Tilemap,
    bgmap: Tilemap,
  },

  audio: record{
    music: Music,
    sound_effects: record{
      land: Sound,
      hit: Sound
    }
  },
}

function Resources:unload()
  self.font:destroy()
  self.sprites_and_bg:destroy()

  self.maps.map:destroy()
  self.maps.bgmap:destroy()

  self.audio.sound_effects.land:destroy()
  self.audio.sound_effects.hit:destroy()

  self.audio.music:destroy()
end

local Resources.res: Resources

-- Entity Masks --
local EntityMask = @enum{
  Lander = 0b001,
  Floor  = 0b010,
  Safe   = 0b100,
}

-- animations
local animations: record{
  prop_active: AnimationRange,
  prop_inactive: AnimationRange,
} = {
  prop_active   = { fps = 12, from = 0, to = 1, loop = true, },
  prop_inactive = { fps =  1, from = 4, to = 4, },
}

local LanderState = @enum{
  Flying = 1,
  Landed,
  Crashed,
}

-- components --
local LanderController <nickname 'LanderController'> = @component(record{
  propulsion_force: number,
  state: LanderState
})

-- entities --
local Ground <nickname 'Ground'> = @entity(record{
  position: Position,
  collider: Collider,
  entity_data: EntityData,
})

function Ground.init(rect: Rect, mask: EntityMask): Ground
  local ground: Ground = {
    position = {
      local_pos = { rect.x, rect.y },
    },

    collider = {
      hitbox = { 0,0 , rect.w, rect.h },
    },

    entity_data = {
      =mask,
    }
  }

  return ground
end

local SafeLanding <nickname 'SafeLanding'> = @derived_entity(Ground, record{})
local SafeLanding.storage: storage(SafeLanding, 11)

function SafeLanding.spawn(rect: Rect)
  local ground = Ground.init(rect, EntityMask.Safe)
  local safe_landing = utils.copy_entity(&ground, @SafeLanding)

  local ok, id, safe_landing = SafeLanding.storage:push(safe_landing)
  assert(ok, "Couldn't add a safe landing entity")

  safe_landing.entity_data.id = id
end

local Floor <nickname 'Floor'> = @derived_entity(Ground, record{})
local Floor.storage: storage(Floor, 512)

function Floor.spawn(rect: Rect)
  local ground = Ground.init(rect, EntityMask.Floor)
  local floor = utils.copy_entity(&ground, @Floor)

  local ok, id, floor = Floor.storage:push(floor)
  assert(ok, "Couldn't add a floor entity")

  floor.entity_data.id = id
end

local LanderPropulsion <nickname 'LanderPropulsion'> = @entity(record{
  position: Position,
  sprite: Sprite,
})

function LanderPropulsion.init(): LanderPropulsion
  local propulsion: LanderPropulsion = {
    position = {
      local_pos = { 0, 16 },
    },

    sprite = {
      active = true,
      texture = Resources.res.sprites_and_bg,
      frame_rect = { 0,0 , 16,16 },
      animation_running = true,
      current_animation = animations.prop_inactive,
    },
  }

  return propulsion
end

local Lander <nickname 'Lander'> = @entity(record{
  position: Position,
  sprite: Sprite,
  velocity: Velocity,
  gravity: Gravity,
  collider: Collider,
  entity_data: EntityData,

  controller: LanderController,

  propulsion: LanderPropulsion,
  camera: PixelArtCamera,
})

local Lander.storage: storage(Lander, 1)

-- collision reaction callbacks
function Lander.on_begin_collision(collision_data: Collider.CollisionData)
  local ok, lander = Lander.storage:mget(collision_data.self.entity_data.id)
  assert(ok, "Couldn't find lander")

  switch collision_data.other.entity_data.mask do
  case EntityMask.Safe then
    lander.controller.state = LanderState.Landed
    Resources.res.audio.sound_effects.land:play()

  case EntityMask.Floor then
    lander.controller.state = LanderState.Crashed
    Resources.res.audio.sound_effects.hit:play()
  end
end

function Lander.on_end_collision(collision_data: Collider.CollisionData)
  local ok, lander = Lander.storage:mget(collision_data.self.entity_data.id)
  assert(ok, "Couldn't find lander")

  if collision_data.other.entity_data.mask  == EntityMask.Safe then
    lander.controller.state = LanderState.Flying
  end
end

function Lander.spawn(): GenIdx
  local gravity_acceleration <comptime> = 30

  local ok, id, lander = Lander.storage:push({
    position = {
      local_pos = Lander_Start_Position,
    },

    sprite = {
      active = true,
      texture = Resources.res.sprites_and_bg,
      frame_rect = { 64,16, 16,16 },
    },

    velocity = {
      active = true,
      max_velocity = LANDER_MAX_VELOCITY,
      velocity_is_limited = true,
      use_deltatime = true,
    },

    gravity = {
      active = true,
      acceleration = gravity_acceleration,
      direction = { 0, 1 },
    },

    collider = {
      active = true,
      hitbox = { 0,0 , 16,16 },
      collision_mask = EntityMask.Floor | EntityMask.Safe,
      with_collision = true,
      corner_tolerance = 2,
      on_begin_collision = Lander.on_begin_collision,
      on_end_collision   = Lander.on_end_collision,
    },

    entity_data = {
      mask = EntityMask.Lander,
    },

    controller = {
      propulsion_force = gravity_acceleration * 2.5,
      state = LanderState.Flying,
    },

    propulsion = LanderPropulsion.init(),

    camera = PixelArtCamera.init({}, {8, 8}, 2),
  })
  assert(ok, 'could not create lander entity')

  lander.entity_data.id = id

  return id
end

function Lander:reset()
  self.controller.state = LanderState.Flying
  self.position.local_pos = Lander_Start_Position
  self.velocity.final_velocity = {}
end

local LunarMap <nickname 'LunarMap'> = @entity(record{
  position: Position,
  tilemap: TilemapComp,
})

function LunarMap.init(pos: Vec2, tilemap: Tilemap): LunarMap
  local lunarmap: LunarMap = {
    position = {
      local_pos = pos
    },

    tilemap = {
      =tilemap,
      tileset = Resources.res.sprites_and_bg
    },
  }

  return lunarmap
end

-- this function depends on entities, thus it's declared after them
function Resources:load()
  -- audio
  local ok, music = Music.load('tests/lunar-lander/assets/lunar-lander-music.ogg')
  assert(ok, 'Could not load "Lunar Lander" music')
  self.audio.music = music

  local ok, land = Sound.load('tests/lunar-lander/assets/land.wav')
  assert(ok, 'Could not load "land" sound effect')
  self.audio.sound_effects.land = land

  local ok, hit = Sound.load('tests/lunar-lander/assets/hit.wav')
  assert(ok, 'Could not load "hit" sound effect')
  self.audio.sound_effects.hit = hit

  -- texture sprites
  local ok, texture= Texture.load('tests/lunar-lander/assets/figures/sprites.png')
  assert(ok, 'Could not load "sprites" texture')
  self.sprites_and_bg = texture

  -- font
  local ok, font = Font.load('nene/resources/monogram_extended.ttf', 16)
  self.font = font

  do --maps
    local _map: vector(isize) = {}

    ##[[
      local function from_cr_to_pos(column, row) return (column - 1) * 16, (row - 1) * 16 end
      local function from_wh_to_size(w, h) return w * 16, h * 16 end
      local charframe = { f = 6, s = 7 }
      local level_map = require 'tests.lunar-lander.assets.map'
    ]]

    ## local function fn_all(column, row, char)
      _map:push(#[charframe[char] or -1]#)
    ## end

    ## local function set_lander_start_pos (column, row)
      ## local pos_x, pos_y = from_cr_to_pos(column, row)
      Lander_Start_Position = { #[pos_x]# + 2, #[pos_y]# }
    ## end

    ## local function create_floor(rect)
      ## local pos_x, pos_y = from_cr_to_pos(rect.x, rect.y)
      ## local size_x, size_y = from_wh_to_size(rect.w, rect.h)
      Floor.spawn({ #[pos_x]#, #[pos_y]#, #[size_x]#, #[size_y]# })
    ## end

    ## local function create_safe(rect)
      ## local pos_x, pos_y = from_cr_to_pos(rect.x, rect.y)
      ## local size_x, size_y = from_wh_to_size(rect.w, rect.h)
      SafeLanding.spawn({ #[pos_x]#, #[pos_y]#, #[size_x]#, #[size_y]# })
    ## end

    ##[[
      local map = textmap.from_text(level_map)
      map_caller(map, fn_all, { L = set_lander_start_pos }, { f = create_floor, s = create_safe })
    ]]

    self.maps.map = {
      tilemap_width = 50,
      tileset_width = 5,
      grid = { cell_size = { 16, 16 } },
      map = _map,
    }

    self.maps.bgmap = {
      tilemap_width = 25,
      tileset_width = 5,
      grid = { cell_size = { 32, 32 } },
      map = {
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
      }
    }
  end
end

-- system --

local LanderControllerSystem = @record{}
local LanderControllerSystem.Filter = @record{
  sprite: *Sprite,
  lander_controller: *LanderController,
  propulsion: *LanderPropulsion,
  velocity: *Velocity,
}

function LanderControllerSystem:run(e: LanderControllerSystem.Filter)
  local is_right_down = nene:get_scancode(Scancode.Right)
  local is_left_down  = nene:get_scancode(Scancode.Left)
  local is_up_down    = nene:get_scancode(Scancode.Up)

  e.propulsion.sprite:set_animation(is_up_down and animations.prop_active or animations.prop_inactive, nene.current_time)

  if is_right_down or is_up_down or is_left_down then
    local direction: Vec2 = { y = is_up_down and -1 or 0 }

    if is_right_down then
      direction.x = 1
    elseif is_left_down then
      direction.x = -1
    end

    e.velocity:add_velocity(direction * e.lander_controller.propulsion_force * nene.delta_time)
  end
end

-- Game State --
local GameState = @record{
  -- entities
  lander_id: GenIdx,
  --maps
  lunarmaps: record{
    map: LunarMap,
    bgmap: LunarMap,
  },
  -- systems
  systems: record{
    lander_ctrl_system: system(LanderControllerSystem.run),

    gravity_system: system(GravitySystem.run),
    velocity_system: system(VelocitySystem.run),
    sprite_animation: system(SpriteAnimation.run),
    sprite_painter: system(SpritePainterSystem.run),
    collision_system: system(CollisionSystem.run),
    tilemap_painter: system(TilemapPainter.run),
    camera_system: system(CameraSystem.run),
    position_hierarchy: system(PositionHierarchySystem.run),
    interrupt_velocity_by_collision_system: system(InterruptVelocityByCollisionSystem.run),

    pixelcamera_render_begin: system(PixelArtCamera.System.render_begin),
    pixelcamera_render_end: system(PixelArtCamera.System.render_end),
    pixelcamera_draw_screens: system(PixelArtCamera.System.draw_screens),
  },
  -- useful data
  last_startmusic_time: float32,
  is_paused: boolean,
}

function GameState:init()
  self.lunarmaps.bgmap = LunarMap.init({0,16}, Resources.res.maps.bgmap)
  self.lunarmaps.map =  LunarMap.init({0,0}, Resources.res.maps.map)

  self.lander_id = Lander.spawn()
end

function GameState:reset()
  local ok, lander = Lander.storage:mget(self.lander_id)
  assert(ok, "Couldn't get lander entity")
  lander:reset()

  self.is_paused = false
end

function GameState:unload()
  Music.stop()
  self.systems.collision_system.data.collidables:destroy()
end

function GameState:run_system(sysname: string <comptime>, pre_run: facultative(boolean), post_run: facultative(boolean))
  ## prof(sysname.value)

  local system = &self.systems.#|sysname.value|#

  ## if not pre_run.type.is_niltype then
    if pre_run then
      system.data:pre_run()
    end
  ## end

  system:run(
    &self.lunarmaps.bgmap,
    &self.lunarmaps.map,
    &SafeLanding.storage,
    &Floor.storage,
    &Lander.storage
  )

  ## if not post_run.type.is_niltype then
    if post_run then
      system.data:post_run()
    end
  ## end
end

local Game_State: GameState

-- game init --
Resources.res:load()
defer Resources.res:unload() end

Game_State:init()
defer Game_State:unload() end

local landed_txt <close> = TextTexture.init("You Landed!", Resources.res.font)
local crashed_txt <close> = TextTexture.init("You Crashed!", Resources.res.font)
local paused_txt <close> = TextTexture.init("Paused", Resources.res.font)
local fps_txt <close> = TextTexture.init("00", Resources.res.font)

-- game functions --
local function paint_dev_info()
  nene:render_draw_line({SCREEN_WIDTH // 2, 0}, {SCREEN_WIDTH // 2, SCREEN_HEIGHT}, Color.Palette.yellow)
  nene:render_draw_line({0, SCREEN_HEIGHT // 2}, {SCREEN_WIDTH, SCREEN_HEIGHT // 2}, Color.Palette.yellow)

  local fps = 1 / nene.delta_time
  local fps_str <close> = (do
    local fps_num_str <close> = tostring(fps)
    local fps_fps_str = 'FPS: ' .. fps_num_str
    in fps_fps_str
  end)

  fps_txt:update_text(fps_str, Resources.res.font)
  fps_txt:draw({8, 8}, Color.Palette.red)
end

local function flying_systems()
  ## prof('flying systems')

  Game_State:run_system('gravity_system')
  Game_State:run_system('lander_ctrl_system')

  Game_State:run_system('collision_system', true, true)
  Game_State:run_system('interrupt_velocity_by_collision_system')

  Game_State:run_system('velocity_system')

  Game_State:run_system('position_hierarchy')

  Game_State:run_system('sprite_animation')
end

local function update()
  ## prof('processing systems')

  local ok, lander = Lander.storage:mget(Game_State.lander_id)
  assert(ok, "Couldn't get lander entity")

  local is_flying = lander.controller.state == LanderState.Flying

  local nene = Nene.instance()

  if nene:get_scancode_down(Scancode.P) and is_flying then
    Game_State.is_paused = not Game_State.is_paused
  end

  if Game_State.is_paused then
    return
  end

  if is_flying then
    flying_systems()
  end
end

local function paint_game()
  ## prof('paint game')

  Game_State:run_system('camera_system')
  Game_State:run_system('tilemap_painter')
  Game_State:run_system('sprite_painter')
end

local function draw_text(tex_txt: TextTexture)
  local half_screen: Vec2 = { (SCREEN_WIDTH // 2), (SCREEN_HEIGHT // 2) }
  local half_tex_size: Vec2 = { tex_txt.texture.width // 2, tex_txt.texture.height // 2 }

  local draw_pos = half_screen - half_tex_size

  tex_txt:draw(draw_pos + Vec2{1, 1}, Color.Palette.black)
  tex_txt:draw(draw_pos, Color.Palette.white)
end

local function draw_stop_flying_text(lander_state: LanderState)
  local tex_txt: TextTexture = lander_state == LanderState.Landed and landed_txt or crashed_txt
  draw_text(tex_txt)
end

local function paint_hud(show_dev_info: boolean)
  ## prof('paint hud')

  local ok, lander = Lander.storage:mget(Game_State.lander_id)
  assert(ok, "Couldn't get lander entity")

  local is_flying = lander.controller.state == LanderState.Flying

  if Game_State.is_paused then
    draw_text(paused_txt)
  elseif not is_flying then
    draw_stop_flying_text(lander.controller.state)
  end

  if show_dev_info then
    paint_dev_info()
  end
end

local function draw()
  ## prof('draw')

  Game_State:run_system('pixelcamera_render_begin')

  local show_dev_info = nene:get_scancode(Scancode.I)

  paint_game()

  if show_dev_info then
    Game_State.systems.collision_system.data:draw_hitboxes()
  end

  nene.render_offset = {}

  paint_hud(show_dev_info)

  Game_State:run_system('pixelcamera_render_end')
  Game_State:run_system('pixelcamera_draw_screens')
end

-- Main Loop --
Resources.res.audio.music:play()

repeat
  nene:poll_events()

  if nene:get_scancode(Scancode.R) then
    Game_State:reset()
  end

  update()
  draw()

  ## if PROF then
    nprof:draw()
    nprof:reset()
  ## end

  nene:render_present()
until nene.quit
