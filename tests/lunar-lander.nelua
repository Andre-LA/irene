-- [[ requires and imports [[
require 'math'

require 'raylib'
require 'rotor'
require 'rotor-quick'
require 'rotor-quick.makers'

local Position = RotorQuick.Components.Position
local Shape = RotorQuick.Components.Shape
local Painter = RotorQuick.Components.Painter
local Velocity = RotorQuick.Components.Velocity
local Gravity = RotorQuick.Components.Gravity
local Intersectable = RotorQuick.Components.Intersectable
local Intersections = RotorQuick.Components.Intersections
local Sprite = RotorQuick.Components.Sprite

local GravityApplier = RotorQuick.Systems.GravityApplier
local ShapePainter = RotorQuick.Systems.ShapePainter
local VelocityApplier = RotorQuick.Systems.VelocityApplier
local IntersectableUpdate = RotorQuick.Systems.IntersectableUpdate
local IntersectablePainter = RotorQuick.Systems.IntersectablePainter
local IntersectionsDetector = RotorQuick.Systems.IntersectionsDetector
local IntersectionsPainter = RotorQuick.Systems.IntersectionsPainter
local SpritePainter = RotorQuick.Systems.SpritePainter

-- ]] requires and imports ]]

-- Main Game Record and general variables
local screen_width: integer <comptime> = 800
local screen_height: integer <comptime> = 608

local LANDER_MAX_VELOCITY <comptime> = 10
local Lander_Start_Position: Vector2 = {32, 32}

Raylib.SetConfigFlags(ConfigFlag.FLAG_WINDOW_RESIZABLE)
Raylib.InitWindow(screen_width, screen_height, "raylib [core] example - basic window")
Raylib.InitAudioDevice()
Raylib.SetTargetFPS(60)

-- [[ components [[

local IsSafeLanding = @record{a: byte}
## is_component('is_safe_landing', IsSafeLanding)

local IsFloor = @record{ a: byte }
## is_component('is_floor', IsFloor)

local LanderState = @enum {
  Flying = 1,
  Landed,
  Crashed,
}

local LanderController = @record{
  propulsion_force: number,
  state: LanderState
}
## is_component('lander_ctrl', LanderController)

-- ]] components ]]

-- [[ systems [[

global LanderControllerRunner = @record{}

function LanderControllerRunner:run(lander_ctrl: *LanderController,
                                    velocity: *Velocity,
                                    gravity: *Gravity,
                                    system_data: *SystemData
                                    )
  local is_right_down, is_up_down, is_left_down = Raylib.IsKeyDown(KeyboardKey.KEY_RIGHT),
                                                  Raylib.IsKeyDown(KeyboardKey.KEY_UP),
                                                  Raylib.IsKeyDown(KeyboardKey.KEY_LEFT)

  if is_right_down or is_up_down or is_left_down then
    local direction: Vector2 = {
      x = (do
        if is_right_down then
          return 1
        elseif is_left_down then
          return -1
        else
          return 0
        end
      end),

      y = (do
        if is_up_down then
          return -1
        else
          return 0
        end
      end)
    }

    velocity:add_velocity(direction * lander_ctrl.propulsion_force)
  end
end

local LanderControllerSystem = @MakeSystem(LanderControllerRunner, false, true, false, 1, @record{
  lander_ctrl: LanderController,
  velocity: Velocity,
  gravity: Gravity,
})

-- ]] systems ]]

-- [[ entities [[

local SafeLanding = #[make_entity{
  {'position', Position},
  {'shape', Shape},
  {'sprite', Sprite},
  {'painter', Painter},
  {'intersectable', Intersectable},
  {'is_safe_landing', IsSafeLanding},
}]#

local Floor = #[make_entity{
  {'position', Position},
  {'shape', Shape},
  {'sprite', Sprite},
  {'painter', Painter},
  {'intersectable', Intersectable},
  {'is_floor', IsFloor},
}]#

local Lander = #[make_entity{
  {'position', Position},
  {'shape', Shape},
  {'sprite', Sprite},
  {'painter', Painter},
  {'velocity', Velocity},
  {'gravity', Gravity},
  {'intersectable', Intersectable},
  {'intersections', Intersections},

  {'lander_ctrl', LanderController},
}]#

-- ]] entities ]]

-- [[ Game State [[

local GameState = @record{
  lander: Lander,
  systems: record{
    lander_ctrl_system: LanderControllerSystem,
    gravity_applier: GravityApplier,
    shape_painter: ShapePainter,
    velocity_applier: VelocityApplier,
    intersectable_update: IntersectableUpdate,
    intersectable_painter: IntersectablePainter,
    intersections_detector: IntersectionsDetector,
    intersections_painter: IntersectionsPainter,
    sprite_painter: SpritePainter
  },
  audio: record{
    music: record{ -- using something similar to double buffering, since our music is not "loop-friendly"
      music1: Music,
      music2: Music,
    },
    sound_effects: record{
      propulsion: Sound,
      land: Sound,
      hit: Sound
    }
  }
}

function GameState:unload()
  Raylib.StopSoundMulti()
  Raylib.UnloadSound(self.audio.sound_effects.propulsion)
  Raylib.UnloadSound(self.audio.sound_effects.land)
  Raylib.UnloadSound(self.audio.sound_effects.hit)

  Raylib.StopMusicStream(self.audio.music.music1)
  Raylib.StopMusicStream(self.audio.music.music2)

  Raylib.UnloadMusicStream(self.audio.music.music1)
  Raylib.UnloadMusicStream(self.audio.music.music2)
end

function GameState:manage_music()
  local music_end_time: number <comptime> = 60 * 2 + 24.1 -- 2:24 is when the music ends and should loop

  if (Raylib.GetMusicTimePlayed(self.audio.music.music1) >= music_end_time and
      not Raylib.IsMusicPlaying(self.audio.music.music2))
  then
    Raylib.PlayMusicStream(self.audio.music.music2)
  elseif (Raylib.GetMusicTimePlayed(self.audio.music.music2) >= music_end_time and
          not Raylib.IsMusicPlaying(self.audio.music.music1))
  then
    Raylib.PlayMusicStream(self.audio.music.music1)
  end

  Raylib.UpdateMusicStream(self.audio.music.music1)
  Raylib.UpdateMusicStream(self.audio.music.music2)
end

function GameState:update_systems(entity: *Entity)
  self.systems.lander_ctrl_system.system.system_data:update(entity)

  self.systems.gravity_applier.system.system_data:update(entity)
  self.systems.shape_painter.system.system_data:update(entity)
  self.systems.velocity_applier.system.system_data:update(entity)
  self.systems.intersectable_update.system.system_data:update(entity)
  self.systems.intersectable_painter.system.system_data:update(entity)
  self.systems.intersections_detector.system.system_data:update(entity)
  self.systems.intersections_painter.system.system_data:update(entity)
  self.systems.sprite_painter.system.system_data:update(entity)
end

function GameState:reset()
  local lander_ctrl = self.lander:get_lander_ctrl(RotorQuick.storages.lander_ctrl)
  lander_ctrl.state = LanderState.Flying

  local position = self.lander:get_position(RotorQuick.storages.position)
  position.position = Lander_Start_Position

  local velocity = self.lander:get_velocity(RotorQuick.storages.velocity)
  velocity:reset_velocity()

  local intersectable = self.lander:get_intersectable(RotorQuick.storages.intersectable)
  intersectable:set_global_rect(position.position)
end

function GameState:create_safe_landing(pos: Vector2)
  local safe_landing_shape: Shape = {
    category = Shape.ShapeCategory.Polygon,
    vertices = { {0, 0}, {16, 0}, {16, 16}, {0,16}, {0, 0} }
  }

  local safe_landing_sprite: Sprite = {
    sprite_sheet = Raylib.LoadTexture("resources/lunar_safe_land.png"),
    frame_index = 0,
    frame_rect = { 0, 0, 16, 16 },
    offset = { 0, 0 },
    visible = true
  }

  local safe_landing, safe_landing_entity = SafeLanding.new(
    RotorQuick.storages.entity,
    {
      --[[position       ]] { position = pos },
      --[[shape          ]] safe_landing_shape,
      --[[sprite         ]] safe_landing_sprite,
      --[[painter        ]] { color = WHITE, active = true },
      --[[intersectable  ]] {},
      --[[is_safe_landing]] {}
    }
  )

  local intersectable = safe_landing:get_intersectable(RotorQuick.storages.intersectable)
  intersectable:identify(safe_landing.entity_id)
  intersectable:set_rects(pos, safe_landing_shape.vertices.data)

  self:update_systems(safe_landing_entity)
end

function GameState:create_floor(pos: Vector2)
  local floor_shape: Shape = {
    category = Shape.ShapeCategory.Polygon,
    vertices = { {0, 0}, {16, 0}, {16, 16}, {0,16}, {0, 0} }
  }

  local floor_sprite: Sprite = {
    sprite_sheet = Raylib.LoadTexture("resources/lunar_floor.png"),
    frame_index = 0,
    frame_rect = { 0, 0, 16, 16 },
    offset = { 0, 0 },
    visible = true
  }

  local floor, floor_entity = Floor.new(
    RotorQuick.storages.entity,
    {
      --[[position     ]] { position = pos },
      --[[shape        ]] floor_shape,
      --[[sprite       ]] floor_sprite,
      --[[painter      ]] { color = WHITE, active = true },
      --[[intersectable]] {},
      --[[is_floor     ]] {}
    }
  )

  local intersectable = floor:get_intersectable(RotorQuick.storages.intersectable)
  intersectable:identify(floor.entity_id)
  intersectable:set_rects(pos, floor_shape.vertices.data)

  self:update_systems(floor_entity)
end

local Game_State: GameState = {
  lander = {},
  systems = {
    lander_ctrl_system = LanderControllerSystem.new(),
    gravity_applier = GravityApplier.new(),
    shape_painter = ShapePainter.new(),
    velocity_applier = VelocityApplier.new(),
    intersectable_update = IntersectableUpdate.new(),
    intersectable_painter = IntersectablePainter.new(),
    intersections_detector = IntersectionsDetector.new(),
    intersections_painter = IntersectionsPainter.new(),
    sprite_painter = SpritePainter.new()
  },
  audio = {
    music = {
      music1 = Raylib.LoadMusicStream("resources/lunar-lander-music.ogg"),
      music2 = Raylib.LoadMusicStream("resources/lunar-lander-music.ogg")
    },
    sound_effects = {
      propulsion = Raylib.LoadSound("resources/propulsion.wav"),
      land = Raylib.LoadSound("resources/land.wav"),
      hit = Raylib.LoadSound("resources/hit.wav")
    }
  }
}

Game_State.audio.music.music1.loopCount = 1
Game_State.audio.music.music2.loopCount = 1

-- ]] Game State ]]

-- [[ callbacks [[

local function intersected_is_floor(other_intersectable: *Intersectable)
local opt_other_entity = RotorQuick.storages.entity:get_entry(other_intersectable.entity_id)

  if opt_other_entity.filled then
    local other_entity = opt_other_entity:get()
    local opt_other_is_floor_idx = other_entity:get_storage_index(RotorQuick.masks.is_floor)
    return opt_other_is_floor_idx.filled
  end

  return false
end

local function intersected_is_safe_landing(other_intersectable: *Intersectable)
local opt_other_entity = RotorQuick.storages.entity:get_entry(other_intersectable.entity_id)

  if opt_other_entity.filled then
    local other_entity = opt_other_entity:get()
    local opt_other_is_safe_landing_idx = other_entity:get_storage_index(RotorQuick.masks.is_safe_landing)
    return opt_other_is_safe_landing_idx.filled
  end

  return false
end

local function on_lander_intersect_enter(lander: *Lander, self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
  if intersected_is_safe_landing(other_intersectable) then
    local lander_ctrl = lander:get_lander_ctrl(RotorQuick.storages.lander_ctrl)
    lander_ctrl.state = LanderState.Landed

    Raylib.PlaySoundMulti(Game_State.audio.sound_effects.land)

  elseif intersected_is_floor(other_intersectable) then
    local lander_ctrl = lander:get_lander_ctrl(RotorQuick.storages.lander_ctrl)
    lander_ctrl.state = LanderState.Crashed

    Raylib.PlaySoundMulti(Game_State.audio.sound_effects.hit)
  end
end

local function on_lander_intersect_exit(lander: *Lander, self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
  if intersected_is_safe_landing(other_intersectable) then
    local lander_ctrl = lander:get_lander_ctrl(RotorQuick.storages.lander_ctrl)
    lander_ctrl.state = LanderState.Flying
  end
end


local function _on_lander_intersect_enter(self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
  on_lander_intersect_enter(Game_State.lander, self_intersectable, self_intersections, other_intersectable)
end

local function _on_lander_intersect_exit(self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
  on_lander_intersect_exit(Game_State.lander, self_intersectable, self_intersections, other_intersectable)
end

-- ]] callbacks ]]

-- [[ Game State extensions [[

function GameState:create_lander(pos: Vector2)
  local gravity_acceleration: number = 0.1

  local lander_shape: Shape = {
    category = Shape.ShapeCategory.Polygon,
    vertices = { {0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8} } -- create 8 "unreal" elements with no actual used values, just for code clarity
  }

  ## local radius = 8
  ## for i = 0, 8 do
    ## local i_rad = i/4 * math.pi
    ## local cos = math.cos(i_rad)
    ## local sin = math.sin(i_rad)

    lander_shape.vertices[ #[i]# ] = {  #[cos*radius + radius]#, #[sin*radius + radius]# }
  ## end

  local lander_sprite: Sprite = {
    sprite_sheet = Raylib.LoadTexture("resources/lunar_lander_sprite.png"),
    frame_index = 0,
    frame_rect = { 0, 0, 16, 16 },
    offset = { 0, 0 },
    visible = true
  }

  local lander, lander_entity = Lander.new(
    RotorQuick.storages.entity,
    {
      --[[Position     ]] { position = pos },
      --[[Shape        ]] lander_shape,
      --[[Sprite       ]] lander_sprite,
      --[[Painter      ]] { color = WHITE, active = true },
      --[[Velocity     ]] { active = true, final_velocity = {0,0}, max_velocity = LANDER_MAX_VELOCITY, velocity_is_limited = true },
      --[[Gravity      ]] { acceleration = gravity_acceleration, direction = {0.0, 1.0}, active = true },
      --[[Intersectable]] {  },
      --[[Intersections]] { intersections = {}, on_enter_callback = _on_lander_intersect_enter, on_exit_callback = _on_lander_intersect_exit },

      --[[Lander Ctrl  ]] { propulsion_force = gravity_acceleration * 2.5, state = LanderState.Flying },
    }
  )

  local intersectable = lander:get_intersectable(RotorQuick.storages.intersectable)
  intersectable:identify(lander.entity_id)
  intersectable:set_rects(pos, lander_shape.vertices.data)

  self:update_systems(lander_entity)

  self.lander = lander
end

-- ]] Game State extensions ]]

-- [[ Game Start [[

##[[
  local map = {
    'ffffffffffffffffffffffffffffffffffffffffffffffffff',
    'f                                                f',
    'f   L                                            f',
    'f                                                f',
    'f                                                f',
    'f                                                f',
    'f               fffffffffffffffffffffffffff      f',
    'f               f                         f      f',
    'f               f                         f      f',
    'fffffffffffffffff                         f      f',
    'f                                         f      f',
    'f                                         f      f',
    'f                              f          f      f',
    'f                              f          f      f',
    'f         fffffff              f          f      f',
    'f         f f   f              f          f      f',
    'f         f f   f              f                 f',
    'f         f f   ffffffffffffffff                 f',
    'f         f f                  f                 f',
    'f         f f                  f                 f',
    'f         f f                  f                 f',
    'f         f f       f          f                 f',
    'f         f f       f          f                 f',
    'f         f f       f          f                 f',
    'f     fffffff     fff          fffffffffffffffffff',
    'f     ff            f                            f',
    'f     f             f                            f',
    'f     f             f                            f',
    'f     f       ffffffffffffffffffffffffff         f',
    'f     f             f                            f',
    'f     f             f                            f',
    'f     f             f                            f',
    'f     f             f                            f',
    'f     fffffff       f       ffffffffffffffffffffff',
    'f                   f                            f',
    'f                   f                            f',
    'f                   f                            f',
    'f                   f                            f',
    'fffffffffffffffffffffffffffffffffsssssssssssffffff',
    'ffffffffffffffffffffffffffffffffffffffffffffffffff',
  }
]]

local tileposition: Vector2 = Vector2.Zero()
##[[
for i = 1, #map do
  local line = map[i]
  local line_len = #line

  for j = 1, line_len do
    local tileletter = string.sub(map[i], j, j)
    local pos_x, pos_y = (j-1) * 16, (i-1) * 16
    ]]

    ## if tileletter ~= ' ' then
      tileposition.x = #[ pos_x ]#
      tileposition.y = #[ pos_y ]#

      ## if tileletter == 'L' then
        Lander_Start_Position = tileposition
      ## elseif tileletter == 'f' then
        Game_State:create_floor(tileposition)
      ## elseif tileletter == 's' then
        Game_State:create_safe_landing(tileposition)
      ##[[
      end
    end
  end
end
]]

Game_State:create_lander(Lander_Start_Position)

Raylib.PlayMusicStream(Game_State.audio.music.music1)

-- ]] Game Start ]]

-- [[ Main Loop [[

while not Raylib.WindowShouldClose() do
  Game_State:manage_music()

  local show_dev_info = Raylib.IsKeyDown(KeyboardKey.KEY_I)

  if Raylib.IsKeyDown(KeyboardKey.KEY_R) then
    Game_State:reset()
  end

  local lander_ctrl = Game_State.lander:get_lander_ctrl(RotorQuick.storages.lander_ctrl)
  local is_flying = lander_ctrl.state == LanderState.Flying

  if is_flying then
    Game_State.systems.gravity_applier:run({&RotorQuick.storages.gravity, &RotorQuick.storages.velocity})
    Game_State.systems.lander_ctrl_system:run({&RotorQuick.storages.lander_ctrl, &RotorQuick.storages.velocity, &RotorQuick.storages.gravity})
    Game_State.systems.velocity_applier:run({&RotorQuick.storages.velocity, &RotorQuick.storages.position})
  end

  Game_State.systems.intersectable_update:run({&RotorQuick.storages.position, &RotorQuick.storages.intersectable})
  Game_State.systems.intersections_detector:run({&RotorQuick.storages.intersectable, &RotorQuick.storages.intersections})

  Raylib.BeginDrawing()
    Raylib.ClearBackground(BLACK)

    Game_State.systems.sprite_painter:run({&RotorQuick.storages.position, &RotorQuick.storages.painter, &RotorQuick.storages.sprite})

    if show_dev_info then
      Game_State.systems.shape_painter:run({&RotorQuick.storages.position, &RotorQuick.storages.shape, &RotorQuick.storages.painter})
      Game_State.systems.intersectable_painter:run({&RotorQuick.storages.intersectable, &RotorQuick.storages.painter})
      Game_State.systems.intersections_painter:run({&RotorQuick.storages.intersections, &RotorQuick.storages.painter})
    end

    if not is_flying then
      local msg = (do
        switch lander_ctrl.state
        case LanderState.Landed then
          return "You're Landed"
        case LanderState.Crashed then
          return "You Crashed"
        else
          return ""
        end
      end)

      local msg_fontsize <comptime> = 18
      local msg_width = Raylib.MeasureText(msg, msg_fontsize)
      Raylib.DrawText(msg, math.ifloor(screen_width / 2 - msg_width / 2), math.ifloor(screen_height / 2), msg_fontsize, WHITE)
    end

  Raylib.EndDrawing()
end
-- ]] Main Loop ]]

Game_State:unload()

Raylib.CloseAudioDevice()
Raylib.CloseWindow()
