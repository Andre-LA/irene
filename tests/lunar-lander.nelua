-- [[ requires and imports [[

require 'math'

require 'raylib'
require 'rotor'
require 'rotor-quick'
require 'rotor-quick.makers'

local Position = RotorQuick.Components.Position
local Shape = RotorQuick.Components.Shape
local Painter = RotorQuick.Components.Painter
local Velocity = RotorQuick.Components.Velocity
local Gravity = RotorQuick.Components.Gravity
local Intersectable = RotorQuick.Components.Intersectable
local Intersections = RotorQuick.Components.Intersections

local GravityApplier = RotorQuick.Systems.GravityApplier
local ShapePainter = RotorQuick.Systems.ShapePainter
local VelocityApplier = RotorQuick.Systems.VelocityApplier
local IntersectableUpdate = RotorQuick.Systems.IntersectableUpdate
local IntersectablePainter = RotorQuick.Systems.IntersectablePainter
local IntersectionsDetector = RotorQuick.Systems.IntersectionsDetector
local IntersectionsPainter = RotorQuick.Systems.IntersectionsPainter

-- ]] requires and imports ]]

-- Main Game Record and general variables
local screen_width: integer <comptime> = 400
local screen_height: integer <comptime> = 304

local LunarLander = @record{}
global LunarLander.storages: record{} = {}
global LunarLander.masks: record {} = {}

-- [[ components [[

local IsFloor = @record{ a: byte }
## is_component('is_floor', IsFloor)

local LanderController = @record{
  propulsion_force: number,
  is_landed: boolean,
}
## is_component('lander_ctrl', LanderController)

-- ]] components ]]

-- [[ systems [[

global LanderControllerRunner = @record{}

function LanderControllerRunner:run(lander_ctrl: *LanderController, velocity: *Velocity, gravity: *Gravity, system_data: *SystemData)
  local is_right_down, is_up_down, is_left_down = Raylib.IsKeyDown(KeyboardKey.KEY_RIGHT),
                                                  Raylib.IsKeyDown(KeyboardKey.KEY_UP),
                                                  Raylib.IsKeyDown(KeyboardKey.KEY_LEFT)
  if lander_ctrl.is_landed then
    velocity:reset_velocity()
  end

  if is_right_down or is_up_down or is_left_down then
    local direction: Vector2 = {
      x = (do
        if is_right_down then
          return 1
        elseif is_left_down then
          return -1
        else
          return 0
        end
      end),

      y = (do
        if is_up_down then
          return -1
        else
          return 0
        end
      end)
    }

    if lander_ctrl.is_landed then
      if is_up_down then
        velocity:add_velocity(direction * lander_ctrl.propulsion_force)
      end
    else
      velocity:add_velocity(direction * lander_ctrl.propulsion_force)
    end
  end
end

local LanderControllerSystem = @MakeSystem(LanderControllerRunner, false, true, false, 1, @record{
  lander_ctrl: LanderController,
  velocity: Velocity,
  gravity: Gravity,
})

local lander_ctrl_system = LanderControllerSystem.new()

local gravity_applier = GravityApplier.new()
local shape_painter = ShapePainter.new()
local velocity_applier = VelocityApplier.new()
local intersectable_update = IntersectableUpdate.new()
local intersectable_painter = IntersectablePainter.new()
local intersections_detector = IntersectionsDetector.new()
local intersections_painter = IntersectionsPainter.new()

local function update_systems(entity: *Entity)
  lander_ctrl_system.system.system_data:update(entity)

  gravity_applier.system.system_data:update(entity)
  shape_painter.system.system_data:update(entity)
  velocity_applier.system.system_data:update(entity)
  intersectable_update.system.system_data:update(entity)
  intersectable_painter.system.system_data:update(entity)
  intersections_detector.system.system_data:update(entity)
  intersections_painter.system.system_data:update(entity)
end

-- ]] systems ]]

-- [[ entities [[

local Floor = #[make_entity{
  {'position', Position},
  {'shape', Shape},
  {'painter', Painter},
  {'intersectable', Intersectable},
  {'is_floor', IsFloor},
}]#

local function create_floor(pos: Vector2)
  local floor_shape: Shape = {
    category = Shape.ShapeCategory.Polygon,
    vertices = { {0, 0}, {16, 0}, {16, 16}, {0,16}, {0, 0} }
  }

  local floor, floor_entity = Floor.new(
    RotorQuick.storages.entity,
    {
      --[[position     ]] { position = pos },
      --[[shape        ]] floor_shape,
      --[[painter      ]] { color = MAGENTA, active = true },
      --[[intersectable]] {},
      --[[is_floor     ]] {}
    }
  )

  local intersectable = floor:get_intersectable(RotorQuick.storages.intersectable)
  intersectable:identify(floor.entity_id)
  intersectable:set_rects(pos, floor_shape.vertices.data)

  update_systems(floor_entity)
end

local Lander = #[make_entity{
  {'position', Position},
  {'shape', Shape},
  {'painter', Painter},
  {'velocity', Velocity},
  {'gravity', Gravity},
  {'intersectable', Intersectable},
  {'intersections', Intersections},

  {'lander_ctrl', LanderController},
}]#

local LANDER_MAX_VELOCITY <comptime> = 10

-- [[ callbacks [[

local lander: Lander <noinit>

local function intersected_is_floor(other_intersectable: *Intersectable)
local opt_other_entity = RotorQuick.storages.entity:get_entry(other_intersectable.entity_id)

  if opt_other_entity.filled then
    local other_entity = opt_other_entity:get()
    local opt_other_is_floor_idx = other_entity:get_storage_index(RotorQuick.masks.is_floor)

    return opt_other_is_floor_idx.filled
  end

  return false
end

local function on_lander_intersect_enter(self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
  if intersected_is_floor(other_intersectable) then
    local lander_ctrl = lander:get_lander_ctrl(RotorQuick.storages.lander_ctrl)
    lander_ctrl.is_landed = true
  end
end

local function on_lander_intersect_exit(self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
  if intersected_is_floor(other_intersectable) then
    local lander_ctrl = lander:get_lander_ctrl(RotorQuick.storages.lander_ctrl)
    lander_ctrl.is_landed = false
  end
end

-- ]] callbacks ]]

local function create_lander(pos: Vector2): Lander
  local gravity_acceleration: number = 0.1

  local lander_shape: Shape = {
    category = Shape.ShapeCategory.Triangle,
    vertices = { {8, 0}, {0, 16}, {16, 16} }
  }

  local lander, lander_entity = Lander.new(
    RotorQuick.storages.entity,
    {
      --[[Position     ]] { position = pos },
      --[[Shape        ]] lander_shape,
      --[[Painter      ]] { color = WHITE, active = true },
      --[[Velocity     ]] { active = true, final_velocity = {0,0}, max_velocity = LANDER_MAX_VELOCITY, velocity_is_limited = true },
      --[[Gravity      ]] { acceleration = gravity_acceleration, direction = {0.0, 1.0}, active = true },
      --[[Intersectable]] {  },
      --[[Intersections]] { intersections = {}, on_enter_callback = on_lander_intersect_enter, on_exit_callback = on_lander_intersect_exit },

      --[[Lander Ctrl  ]] { propulsion_force = gravity_acceleration * 2.5 },
    }
  )

  local intersectable = lander:get_intersectable(RotorQuick.storages.intersectable)
  intersectable:identify(lander.entity_id)
  intersectable:set_rects(pos, lander_shape.vertices.data)

  update_systems(lander_entity)

  return lander
end

lander = create_lander({32, 32})

for i = 0, < 25 do
  for j = 17, < 21 do
    create_floor({16*i, 16*j})
  end
end

-- ]] entities ]]

Raylib.SetConfigFlags(ConfigFlag.FLAG_WINDOW_RESIZABLE)
Raylib.InitWindow(screen_width, screen_height, "raylib [core] example - basic window")
Raylib.SetTargetFPS(60)

while not Raylib.WindowShouldClose() do
  gravity_applier:run({&RotorQuick.storages.gravity, &RotorQuick.storages.velocity})
  lander_ctrl_system:run({&RotorQuick.storages.lander_ctrl, &RotorQuick.storages.velocity, &RotorQuick.storages.gravity})
  velocity_applier:run({&RotorQuick.storages.velocity, &RotorQuick.storages.position})

  intersectable_update:run({&RotorQuick.storages.position, &RotorQuick.storages.intersectable})
  intersections_detector:run({&RotorQuick.storages.intersectable, &RotorQuick.storages.intersections})

  Raylib.BeginDrawing()
    Raylib.ClearBackground(BLACK)

    shape_painter:run({&RotorQuick.storages.position, &RotorQuick.storages.shape, &RotorQuick.storages.painter})
    intersectable_painter:run({&RotorQuick.storages.intersectable, &RotorQuick.storages.painter})
    intersections_painter:run({&RotorQuick.storages.intersections, &RotorQuick.storages.painter})

  Raylib.EndDrawing()
end

Raylib.CloseWindow()

--[[
asteroid = {
  position = {},
  velocity = {},
  asteroid_info = {},
  {
    shape = {},
    intersectable = {},
    shape2intersectable = {}
  },
  {
    shape = {},
    mesh = {},
    shape2mesh = {}.
  },
}

spaceship = {
  spaceship_controller = {},
  position = {},
  velocity = {},
  spaceship_info = {},
  {
    shape = {},
    intersectable = {},
    shape2intersectable = {}
    intersections = {},
  },
  {
    shape = {},
    mesh = {},
    shape2mesh = {}.
  },
}
]]
