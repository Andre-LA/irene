-- [[ requires and imports [[
require 'math'

require 'raylib'
require 'rotor'
require 'rotor-quick'
require 'rotor-quick.makers'

local Position = RotorQuick.Components.Position
local Shape = RotorQuick.Components.Shape
local Painter = RotorQuick.Components.Painter
local Velocity = RotorQuick.Components.Velocity
local Gravity = RotorQuick.Components.Gravity
local Intersectable = RotorQuick.Components.Intersectable
local Intersections = RotorQuick.Components.Intersections
local Sprite = RotorQuick.Components.Sprite
local Follower = RotorQuick.Components.Follower
local CameraHolder = RotorQuick.Components.CameraHolder
local SceneGraphNode = RotorQuick.Components.SceneGraphNode
local Animations = RotorQuick.Components.Animations

local GravityApplier = RotorQuick.Systems.GravityApplier
local ShapePainter = RotorQuick.Systems.ShapePainter
local VelocityApplier = RotorQuick.Systems.VelocityApplier
local IntersectableUpdate = RotorQuick.Systems.IntersectableUpdate
local IntersectablePainter = RotorQuick.Systems.IntersectablePainter
local IntersectionsDetector = RotorQuick.Systems.IntersectionsDetector
local IntersectionsPainter = RotorQuick.Systems.IntersectionsPainter
local SpritePainter = RotorQuick.Systems.SpritePainter
local FollowerSystem = RotorQuick.Systems.FollowerSystem
local CameraHolderSystem = RotorQuick.Systems.CameraHolderSystem
local PositionHierarchy = RotorQuick.Systems.PositionHierarchy
local SpriteAnimation = RotorQuick.Systems.SpriteAnimation

-- ]] requires and imports ]]

-- Main Game Record and general variables
local screen_width: integer <comptime> = 800
local screen_height: integer <comptime> = 608

local LANDER_MAX_VELOCITY <comptime> = 10
local Lander_Start_Position: Vector2 = {32, 32}

Raylib.InitWindow(screen_width, screen_height, "raylib [core] example - basic window")
Raylib.InitAudioDevice()
Raylib.SetTargetFPS(60)

local GameLayers = @enum{
  Background = 0,
  Tiles,
  Propulsion,
  Lander
}

-- [[ components [[

local IsSafeLanding = @record{a: byte}
## is_component(IsSafeLanding)

local IsFloor = @record{ a: byte }
## is_component(IsFloor)

local LanderState = @enum {
  Flying = 1,
  Landed,
  Crashed,
}

local LanderAnimations = @enum {
  Inactive = 0,
  Active
}

local LanderController = @record{
  prop_animations_id: GenerationalIndex,
  propulsion_force: number,
  state: LanderState
}
## is_component(LanderController)

-- ]] components ]]

-- [[ systems [[

global LanderControllerRunner = @record{}

function LanderControllerRunner:run(
  lander_controller: *LanderController,
  velocity: *Velocity,
  gravity: *Gravity,
  system_data: *SystemData
)
  local is_right_down, is_up_down, is_left_down = Raylib.IsKeyDown(KeyboardKey.KEY_RIGHT),
                                                  Raylib.IsKeyDown(KeyboardKey.KEY_UP),
                                                  Raylib.IsKeyDown(KeyboardKey.KEY_LEFT)

  local prop_animations_opt = Animations.get_entry_from_id(lander_controller.prop_animations_id)
  if prop_animations_opt.filled then
    local prop_animations = prop_animations_opt:get()
    prop_animations:change_animation(is_up_down and LanderAnimations.Active or LanderAnimations.Inactive)
  end

  if is_right_down or is_up_down or is_left_down then
    local direction: Vector2 = {
      x = (do
        if is_right_down then
          return 0.6
        elseif is_left_down then
          return -0.6
        else
          return 0
        end
      end),

      y = (do
        if is_up_down then
          return -1
        else
          return 0
        end
      end)
    }

    velocity:add_velocity(direction * lander_controller.propulsion_force)
  end
end

local LanderControllerSystem = @MakeSystem(LanderControllerRunner, false, true, false, 1, @record{
  lander_controller: LanderController,
  velocity: Velocity,
  gravity: Gravity,
})

-- ]] systems ]]

-- [[ entities [[

local SafeLanding = #[make_entity{
  Position,
  Shape,
  Sprite,
  Painter,
  Intersectable,
  IsSafeLanding,
}]#

local Floor = #[make_entity{
  Position,
  Shape,
  Sprite,
  Painter,
  Intersectable,
  IsFloor,
}]#

local Lander = #[make_entity{
  Position,
  SceneGraphNode,
  Shape,
  Sprite,
  Painter,
  Velocity,
  Gravity,
  Intersectable,
  Intersections,

  LanderController
}]#

local CameraEntity = #[make_entity{
  Position,
  SceneGraphNode,
  CameraHolder,
}]#

local LanderPropulsionEntity = #[make_entity{
  Position,
  SceneGraphNode,
  Sprite,
  Animations,
  Painter,
}]#

local BackgroundEntity = #[make_entity{
  Position,
  Sprite,
  Painter,
}]#

-- ]] entities ]]

-- [[ Game State [[

local GameState = @record{
  lander: Lander,
  camera_entity: CameraEntity,
  systems: record{
    lander_ctrl_system: LanderControllerSystem,
    gravity_applier: GravityApplier,
    shape_painter: ShapePainter,
    velocity_applier: VelocityApplier,
    intersectable_update: IntersectableUpdate,
    intersectable_painter: IntersectablePainter,
    intersections_detector: IntersectionsDetector,
    intersections_painter: IntersectionsPainter,
    sprite_painter: SpritePainter,
    follower_system: FollowerSystem,
    camera_holder_system: CameraHolderSystem,
    position_hierarchy: PositionHierarchy,
    sprite_animation: SpriteAnimation,
  },
  resources: record{
    textures: record{
      sprites_tex: Texture2D,
    },
    audio: record{
      music: record{ -- using something similar to double buffering, since our music is not "loop-friendly"
        music1: Music,
        music2: Music,
      },
      sound_effects: record{
        propulsion: Sound,
        land: Sound,
        hit: Sound
      }
    },
  }
}

function GameState:unload()
  Raylib.StopSoundMulti()
  Raylib.UnloadSound(self.resources.audio.sound_effects.propulsion)
  Raylib.UnloadSound(self.resources.audio.sound_effects.land)
  Raylib.UnloadSound(self.resources.audio.sound_effects.hit)

  Raylib.StopMusicStream(self.resources.audio.music.music1)
  Raylib.StopMusicStream(self.resources.audio.music.music2)

  Raylib.UnloadMusicStream(self.resources.audio.music.music1)
  Raylib.UnloadMusicStream(self.resources.audio.music.music2)
end

function GameState:manage_music()
  local music_end_time: number <comptime> = 60 * 2 + 24.1 -- 2:24 is when the music ends and should loop

  if (Raylib.GetMusicTimePlayed(self.resources.audio.music.music1) >= music_end_time and
      not Raylib.IsMusicPlaying(self.resources.audio.music.music2))
  then
    Raylib.PlayMusicStream(self.resources.audio.music.music2)
  elseif (Raylib.GetMusicTimePlayed(self.resources.audio.music.music2) >= music_end_time and
          not Raylib.IsMusicPlaying(self.resources.audio.music.music1))
  then
    Raylib.PlayMusicStream(self.resources.audio.music.music1)
  end

  Raylib.UpdateMusicStream(self.resources.audio.music.music1)
  Raylib.UpdateMusicStream(self.resources.audio.music.music2)
end

function GameState:update_systems(entity: *Entity)
  self.systems.lander_ctrl_system.system.system_data:update(entity)

  self.systems.gravity_applier.system.system_data:update(entity)
  self.systems.shape_painter.system.system_data:update(entity)
  self.systems.velocity_applier.system.system_data:update(entity)
  self.systems.intersectable_update.system.system_data:update(entity)
  self.systems.intersectable_painter.system.system_data:update(entity)
  self.systems.intersections_detector.system.system_data:update(entity)
  self.systems.intersections_painter.system.system_data:update(entity)
  self.systems.sprite_painter.system.system_data:update(entity)
  self.systems.follower_system.system.system_data:update(entity)
  self.systems.camera_holder_system.system.system_data:update(entity)
  self.systems.position_hierarchy.system.system_data:update(entity)
  self.systems.sprite_animation.system.system_data:update(entity)
end

function GameState:reset()
  local lander_controller = self.lander:get_lander_controller()
  lander_controller.state = LanderState.Flying

  local position = self.lander:get_position()
  position.local_position = Lander_Start_Position

  local velocity = self.lander:get_velocity()
  velocity:reset_velocity()

  local intersectable = self.lander:get_intersectable()
  intersectable:set_global_rect(position:get_global_position())
end

local Game_State: GameState = {
  lander = {},
  systems = {
    lander_ctrl_system = LanderControllerSystem.new(),
    gravity_applier = GravityApplier.new(),
    shape_painter = ShapePainter.new(),
    velocity_applier = VelocityApplier.new(),
    intersectable_update = IntersectableUpdate.new(),
    intersectable_painter = IntersectablePainter.new(),
    intersections_detector = IntersectionsDetector.new(),
    intersections_painter = IntersectionsPainter.new(),
    sprite_painter = SpritePainter.new(),
    follower_system = FollowerSystem.new(),
    camera_holder_system = CameraHolderSystem.new(),
    position_hierarchy = PositionHierarchy.new(),
    sprite_animation = SpriteAnimation.new()
  },
  resources = {
    textures = {
      sprites_tex = Raylib.LoadTexture("resources/lunarlander_sprites.png")
    },
    audio = {
      music = {
        music1 = Raylib.LoadMusicStream("resources/lunar-lander-music.ogg"),
        music2 = Raylib.LoadMusicStream("resources/lunar-lander-music.ogg")
      },
      sound_effects = {
        propulsion = Raylib.LoadSound("resources/propulsion.wav"),
        land = Raylib.LoadSound("resources/land.wav"),
        hit = Raylib.LoadSound("resources/hit.wav")
      }
    },
  }
}

Game_State.resources.audio.music.music1.loopCount = 1
Game_State.resources.audio.music.music2.loopCount = 1

function GameState:create_safe_landing(pos: Vector2)
  local safe_landing_shape: Shape = {
    category = Shape.ShapeCategory.Polygon,
    vertices = { {0, 0}, {16, 0}, {16, 16}, {0,16}, {0, 0} }
  }

  local safe_landing_sprite: Sprite = {
    sprite_sheet = Game_State.resources.textures.sprites_tex,
    frame_index = 6,
    frame_rect = { 0, 0, 16, 16 },
    offset = { 0, 0 },
    layer = GameLayers.Tiles,
  }

  local safe_landing, safe_landing_entity = SafeLanding.new{
    --[[position       ]] { local_position = pos },
    --[[shape          ]] safe_landing_shape,
    --[[sprite         ]] safe_landing_sprite,
    --[[painter        ]] { color = WHITE, active = true },
    --[[intersectable  ]] {},
    --[[is_safe_landing]] {}
  }

  local intersectable = safe_landing:get_intersectable()
  intersectable:init(safe_landing.entity_id, pos, safe_landing_shape.vertices.data)

  self:update_systems(safe_landing_entity)
end

function GameState:create_background(pos: Vector2)
  local background_sprite: Sprite = {
    sprite_sheet = Game_State.resources.textures.sprites_tex,
    frame_index = 1,
    frame_rect = { 0, 0, 32, 32 },
    offset = { 0, 0 },
    layer = GameLayers.Background,
  }

  local background, background_entity = BackgroundEntity.new{
    --[[position     ]] { local_position = pos },
    --[[sprite       ]] background_sprite,
    --[[painter      ]] { color = WHITE, active = true },
  }

  self:update_systems(background_entity)
end

function GameState:create_floor(pos: Vector2)
  local floor_shape: Shape = {
    category = Shape.ShapeCategory.Polygon,
    vertices = { {0, 0}, {16, 0}, {16, 16}, {0,16}, {0, 0} }
  }

  local floor_sprite: Sprite = {
    sprite_sheet = Game_State.resources.textures.sprites_tex,
    frame_index = 5,
    frame_rect = { 0, 0, 16, 16 },
    offset = { 0, 0 },
    layer = GameLayers.Tiles,
  }

  local floor, floor_entity = Floor.new{
    --[[position     ]] { local_position = pos },
    --[[shape        ]] floor_shape,
    --[[sprite       ]] floor_sprite,
    --[[painter      ]] { color = WHITE, active = true },
    --[[intersectable]] {},
    --[[is_floor     ]] {}
  }

  local intersectable = floor:get_intersectable()
  intersectable:init(floor.entity_id, pos, floor_shape.vertices.data)

  self:update_systems(floor_entity)
end

function GameState:create_camera_entity()
  local camera_entity, camera_entity_entity = CameraEntity.new{
    --[[position        ]] {},
    --[[scene_graph_node]] {},
    --[[camera_holder   ]] {
      camera = {
        offset = { screen_width / 2, screen_height / 2  },
        rotation = 0,
        zoom = 3,
      }
    }
  }

  local scene_graph_node = camera_entity:get_scene_graph_node()
  scene_graph_node:init(camera_entity.entity_id, camera_entity.scene_graph_node_id)

  self:update_systems(camera_entity_entity)

  self.camera_entity = camera_entity
end

function GameState:create_lander_propulsion(): LanderPropulsionEntity
  local lander_propulstion_sprite: Sprite = {
    sprite_sheet = Game_State.resources.textures.sprites_tex,
    frame_index = 0,
    frame_rect = { 0, 0, 16, 16 },
    offset = { 0, 0 },
    layer = GameLayers.Propulsion,
  }

  local AnimationUnit = Animations.AnimationUnit

  local lander_propulstion_animations: Animations = {
    animations = {
      --[[inactive]] {
        frames = { {4, 0} },
        looping = false,
        frame_callback = nilptr,
        duration = 1,
      },
      --[[active] ]] {
        frames = { {0, 0}, {1, 0.5} },
        looping = true,
        frame_callback = nilptr,
        duration = 0.06,
      },
    },
    last_change_time = os.clock()
  }

  local lander_propulsion, lander_propulsion_entity = LanderPropulsionEntity.new{
    --[[position        ]] {},
    --[[scene_graph_node]] {},
    --[[sprite          ]] lander_propulstion_sprite,
    --[[animations      ]] lander_propulstion_animations,
    --[[painter         ]] { color = WHITE, active = true }
  }

  local position = lander_propulsion:get_position()
  position:set_local_position({ 0, 16 })

  local scene_graph_node = lander_propulsion:get_scene_graph_node()
  scene_graph_node:init(lander_propulsion.entity_id, lander_propulsion.scene_graph_node_id)

  self:update_systems(lander_propulsion_entity)

  return lander_propulsion
end

-- ]] Game State ]]

-- [[ callbacks [[

local function intersected_is_floor(other_intersectable: *Intersectable)
  local opt_other_entity = RotorQuick.storages.entity:get_entry(other_intersectable.entity_id)

  if opt_other_entity.filled then
    local other_entity = opt_other_entity:get()
    local opt_other_is_floor_idx = other_entity:get_storage_index(RotorQuick.masks.is_floor)
    return opt_other_is_floor_idx.filled
  end

  return false
end

local function intersected_is_safe_landing(other_intersectable: *Intersectable)
local opt_other_entity = RotorQuick.storages.entity:get_entry(other_intersectable.entity_id)

  if opt_other_entity.filled then
    local other_entity = opt_other_entity:get()
    local opt_other_is_safe_landing_idx = other_entity:get_storage_index(RotorQuick.masks.is_safe_landing)
    return opt_other_is_safe_landing_idx.filled
  end

  return false
end

local function on_lander_intersect_enter(lander: *Lander, self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
  if intersected_is_safe_landing(other_intersectable) then
    local lander_controller = lander:get_lander_controller()
    lander_controller.state = LanderState.Landed

    Raylib.PlaySoundMulti(Game_State.resources.audio.sound_effects.land)

  elseif intersected_is_floor(other_intersectable) then
    local lander_controller = lander:get_lander_controller()
    lander_controller.state = LanderState.Crashed

    Raylib.PlaySoundMulti(Game_State.resources.audio.sound_effects.hit)
  end
end

local function on_lander_intersect_exit(lander: *Lander, self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
  if intersected_is_safe_landing(other_intersectable) then
    local lander_controller = lander:get_lander_controller()
    lander_controller.state = LanderState.Flying
  end
end

-- ]] callbacks ]]

-- [[ Game State extensions [[

function GameState:create_lander(pos: Vector2, camera_scene_graph_node_id: GenerationalIndex)
  local lander_propulsion: LanderPropulsionEntity = self:create_lander_propulsion()

  local gravity_acceleration: number = 0.1

  local lander_shape: Shape = {
    category = Shape.ShapeCategory.Polygon,
    vertices = { {0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8} } -- create 8 "unreal" elements with no actual used values, just for code clarity
  }

  ##[[
  local radius = 8
  for i = 0, 8 do
    local i_rad = i/4 * math.pi
    local cos = math.cos(i_rad)
    local sin = math.sin(i_rad)
    ]]

    lander_shape.vertices[ #[i]# ] = { #[cos*radius + radius]#, #[sin*radius + radius]# }
  ## end

  local lander_sprite: Sprite = {
    sprite_sheet = Game_State.resources.textures.sprites_tex,
    frame_index = 9,
    frame_rect = { 0, 0, 16, 16 },
    offset = { 0, 0 },
    layer = GameLayers.Lander
  }

  local lander, lander_entity = Lander.new{
    --[[position        ]] { local_position = pos },
    --[[scene_graph_node]] { },
    --[[shape           ]] lander_shape,
    --[[sprite          ]] lander_sprite,
    --[[painter         ]] {
      active = true,
      color = WHITE
    },
    --[[velocity]] {
      active = true,
      final_velocity = {0,0},
      max_velocity = LANDER_MAX_VELOCITY,
      velocity_is_limited = true
    },
    --[[gravity]] {
      active = true,
      acceleration = gravity_acceleration,
      direction = {0.0, 1.0}
    },
    --[[intersectable]] { },
    --[[intersections]] {
      intersections = {},
      on_enter_callback = function(self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
        on_lander_intersect_enter(Game_State.lander, self_intersectable, self_intersections, other_intersectable)
      end,
      on_exit_callback =  function (self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
        on_lander_intersect_exit(Game_State.lander, self_intersectable, self_intersections, other_intersectable)
      end
    },
    --[[lander_controller]] {
      prop_animations_id = lander_propulsion.animations_id,
      propulsion_force = gravity_acceleration * 2.5,
      state = LanderState.Flying
    },
  }

  local intersectable = lander:get_intersectable()
  intersectable:init(lander.entity_id, pos, lander_shape.vertices.data)

  local lander_scene_graph_node = lander:get_scene_graph_node()
  lander_scene_graph_node:init(lander.entity_id, lander.scene_graph_node_id)

  lander_scene_graph_node:attach_child(camera_scene_graph_node_id)
  lander_scene_graph_node:attach_child(lander_propulsion.scene_graph_node_id)

  self:update_systems(lander_entity)

  self.lander = lander
end

-- ]] Game State extensions ]]

-- [[ Game Start [[

##[[
  local map = {
  -- 0         1         2         3         4
  -- 01234567890123456789012345678901234567890123456789
    'ffffffffffffffffffffffffffffffffffffffffffffffffff',
    'f                                                f',
    'f   L                                            f',
    'f                                                f',
    'f                                                f',
    'f                                                f',
    'f               fffffffffffffffffffffffffff      f',
    'f               f                         f      f',
    'f               f                         f      f',
    'fffffffffffffffff                         f      f',
    'f                                         f      f',
    'f                                         f      f',
    'f                              f          f      f',
    'f                              f          f      f',
    'f         fffffff              f          f      f',
    'f         f f   f              f          f      f',
    'f         f f   f              f                 f',
    'f         f f   ffffffffffffffff                 f',
    'f         f f                  f                 f',
    'f         f f                  f                 f',
    'f         f f                  f                 f',
    'f         f f       f          f                 f',
    'f         f f       f          f                 f',
    'f         f f       f          f                 f',
    'f     fffffff     fff          fffffffffffffffffff',
    'f     ff            f                            f',
    'f     f             f                            f',
    'f     f             f                            f',
    'f     f       ffffffffffffffffffffffffff         f',
    'f     f             f                            f',
    'f     f             f                            f',
    'f     f             f                            f',
    'f     f             f                            f',
    'f     fffffff       f       ffffffffffffffffffffff',
    'f                   f                            f',
    'f                   f                            f',
    'f                   f                            f',
    'f                   f                            f',
    'fffffffffffffffffffffffffffffffffsssssssssssffffff',
    'ffffffffffffffffffffffffffffffffffffffffffffffffff',
  }
]]

## for i = 1, #map do
  ## local line = map[i]
  ## local line_len = #line

  ## for j = 1, line_len do
    ## local tileletter = string.sub(map[i], j, j)
    ## local pos_x, pos_y = (j-1) * 16, (i-1) * 16

    ## local can_place_background = i < line_len and i < #map and pos_x % 32 == 0 and pos_y % 32 == 0

    ## if tileletter == 'L' then
      Lander_Start_Position = { #[pos_x]#, #[pos_y]# }
      ## if can_place_background then
        Game_State:create_background({ #[pos_x]#, #[pos_y]# })
      ## end
    ## elseif tileletter == ' ' and can_place_background then
      Game_State:create_background({ #[pos_x]#, #[pos_y]# })
    ## elseif tileletter == 'f' then
      Game_State:create_floor({ #[pos_x]#, #[pos_y]# })
      ## if can_place_background then
        Game_State:create_background({ #[pos_x]#, #[pos_y]# })
      ## end
    ## elseif tileletter == 's' then
      Game_State:create_safe_landing({ #[pos_x]#, #[pos_y]# })
    ## end
  ## end
## end

Game_State:create_camera_entity()
Game_State:create_lander(Lander_Start_Position, Game_State.camera_entity.scene_graph_node_id)

Raylib.PlayMusicStream(Game_State.resources.audio.music.music1)

-- ]] Game Start ]]

-- [[ Main Loop [[

while not Raylib.WindowShouldClose() do
  Game_State:manage_music()

  local show_dev_info = Raylib.IsKeyDown(KeyboardKey.KEY_I)

  if Raylib.IsKeyDown(KeyboardKey.KEY_R) then
    Game_State:reset()
  end

  local lander_controller = Game_State.lander:get_lander_controller()
  local camera_holder = Game_State.camera_entity:get_camera_holder()

  local is_flying = lander_controller.state == LanderState.Flying

  ## if PROF then
    nprof:push'systems' -- [[ nprof systems [[
  ## end

  do
    ## if PROF then
      nprof:push'processing systems'
      defer nprof:pop() end
    ## end

    if is_flying then
      ## if PROF then
        nprof:push'is flying system'
        defer nprof:pop() end
      ## end

      Game_State.systems.gravity_applier:run()
      Game_State.systems.lander_ctrl_system:run()
      Game_State.systems.velocity_applier:run()
      Game_State.systems.follower_system:run()
    end

    Game_State.systems.position_hierarchy:run()

    Game_State.systems.camera_holder_system:run()

    Game_State.systems.intersectable_update:run()
    Game_State.systems.intersections_detector:run()

    Game_State.systems.sprite_animation:run()
  end

  do Raylib.BeginDrawing()
    ## if PROF then
      nprof:push'drawing systems' -- [[ nprof drawying systems [[
    ## end

    Raylib.ClearBackground(BLACK)

    do Raylib.BeginMode2D(camera_holder.camera)
      ## if PROF then
        nprof:push'painting systems'
        defer nprof:pop() end
      ## end

      Game_State.systems.sprite_painter:run()

      if show_dev_info then
        Game_State.systems.shape_painter:run()
        Game_State.systems.intersectable_painter:run()
        Game_State.systems.intersections_painter:run()
      end


    end Raylib.EndMode2D()

    if not is_flying then
      local msg = (do
        switch lander_controller.state
        case LanderState.Landed then
          return "You're Landed"
        case LanderState.Crashed then
          return "You Crashed"
        else
          return ""
        end
      end)

      local msg_fontsize <comptime> = 18
      local msg_width = Raylib.MeasureText(msg, msg_fontsize)
      Raylib.DrawText(msg, math.ifloor(screen_width / 2 - msg_width / 2), math.ifloor(screen_height / 2), msg_fontsize, WHITE)
    end

    ## if PROF then
      nprof:pop() -- ]] nprof drawying systems ]]
      nprof:pop() -- ]] nprof systems ]]
      nprof:draw()
      nprof:reset()
    ## end

  end Raylib.EndDrawing()
end

-- ]] Main Loop ]]

Game_State:unload()

Raylib.CloseAudioDevice()
Raylib.CloseWindow()
