-- [[ requires and imports [[

require 'math'

require 'raylib'
require 'rotor'
require 'rotor-quick'
require 'rotor-quick.makers'

local Position = RotorQuick.Components.Position
local Shape = RotorQuick.Components.Shape
local Painter = RotorQuick.Components.Painter
local Velocity = RotorQuick.Components.Velocity
local Gravity = RotorQuick.Components.Gravity
local Intersectable = RotorQuick.Components.Intersectable
local Intersections = RotorQuick.Components.Intersections

local GravityApplier = RotorQuick.Systems.GravityApplier
local ShapePainter = RotorQuick.Systems.ShapePainter
local VelocityApplier = RotorQuick.Systems.VelocityApplier
local IntersectableUpdate = RotorQuick.Systems.IntersectableUpdate
local IntersectablePainter = RotorQuick.Systems.IntersectablePainter
local IntersectionsDetector = RotorQuick.Systems.IntersectionsDetector
local IntersectionsPainter = RotorQuick.Systems.IntersectionsPainter

-- ]] requires and imports ]]

-- Main Game Record and general variables
local screen_width: integer <comptime> = 400
local screen_height: integer <comptime> = 304

local LANDER_MAX_VELOCITY <comptime> = 10
local LANDER_START_POSITION: Vector2 = {32, 32}

Raylib.SetConfigFlags(ConfigFlag.FLAG_WINDOW_RESIZABLE)
Raylib.InitWindow(screen_width, screen_height, "raylib [core] example - basic window")
Raylib.SetTargetFPS(60)

-- [[ components [[

local IsSafeLanding = @record{a: byte}
## is_component('is_safe_landing', IsSafeLanding)

local IsFloor = @record{ a: byte }
## is_component('is_floor', IsFloor)

local LanderState = @enum {
  Flying = 1,
  Landed,
  Crashed,
}

local LanderController = @record{
  propulsion_force: number,
  state: LanderState
}
## is_component('lander_ctrl', LanderController)

-- ]] components ]]

-- [[ systems [[

global LanderControllerRunner = @record{}

function LanderControllerRunner:run(lander_ctrl: *LanderController, velocity: *Velocity, gravity: *Gravity, system_data: *SystemData)
  local is_right_down, is_up_down, is_left_down = Raylib.IsKeyDown(KeyboardKey.KEY_RIGHT),
                                                  Raylib.IsKeyDown(KeyboardKey.KEY_UP),
                                                  Raylib.IsKeyDown(KeyboardKey.KEY_LEFT)

  if is_right_down or is_up_down or is_left_down then
    local direction: Vector2 = {
      x = (do
        if is_right_down then
          return 1
        elseif is_left_down then
          return -1
        else
          return 0
        end
      end),

      y = (do
        if is_up_down then
          return -1
        else
          return 0
        end
      end)
    }

    velocity:add_velocity(direction * lander_ctrl.propulsion_force)
  end
end

local LanderControllerSystem = @MakeSystem(LanderControllerRunner, false, true, false, 1, @record{
  lander_ctrl: LanderController,
  velocity: Velocity,
  gravity: Gravity,
})

-- ]] systems ]]

-- [[ entities [[

local SafeLanding = #[make_entity{
  {'position', Position},
  {'shape', Shape},
  {'painter', Painter},
  {'intersectable', Intersectable},
  {'is_safe_landing', IsSafeLanding},
}]#

local Floor = #[make_entity{
  {'position', Position},
  {'shape', Shape},
  {'painter', Painter},
  {'intersectable', Intersectable},
  {'is_floor', IsFloor},
}]#



local Lander = #[make_entity{
  {'position', Position},
  {'shape', Shape},
  {'painter', Painter},
  {'velocity', Velocity},
  {'gravity', Gravity},
  {'intersectable', Intersectable},
  {'intersections', Intersections},

  {'lander_ctrl', LanderController},
}]#

-- [[ callbacks [[

local function intersected_is_floor(other_intersectable: *Intersectable)
local opt_other_entity = RotorQuick.storages.entity:get_entry(other_intersectable.entity_id)

  if opt_other_entity.filled then
    local other_entity = opt_other_entity:get()
    local opt_other_is_floor_idx = other_entity:get_storage_index(RotorQuick.masks.is_floor)
    return opt_other_is_floor_idx.filled
  end

  return false
end

local function intersected_is_safe_landing(other_intersectable: *Intersectable)
local opt_other_entity = RotorQuick.storages.entity:get_entry(other_intersectable.entity_id)

  if opt_other_entity.filled then
    local other_entity = opt_other_entity:get()
    local opt_other_is_safe_landing_idx = other_entity:get_storage_index(RotorQuick.masks.is_safe_landing)
    return opt_other_is_safe_landing_idx.filled
  end

  return false
end

local function on_lander_intersect_enter(lander: *Lander, self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
  if intersected_is_safe_landing(other_intersectable) then
    local lander_ctrl = lander:get_lander_ctrl(RotorQuick.storages.lander_ctrl)
    lander_ctrl.state = LanderState.Landed
  elseif intersected_is_floor(other_intersectable) then
    local lander_ctrl = lander:get_lander_ctrl(RotorQuick.storages.lander_ctrl)
    lander_ctrl.state = LanderState.Crashed
  end
end

local function on_lander_intersect_exit(lander: *Lander, self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
  if intersected_is_safe_landing(other_intersectable) then
    local lander_ctrl = lander:get_lander_ctrl(RotorQuick.storages.lander_ctrl)
    lander_ctrl.state = LanderState.Flying
  end
end

-- ]] callbacks ]]

-- ]] entities ]]

-- [[ Game State [[

local GameState = @record{
  lander: Lander,
  systems: record{
    lander_ctrl_system: LanderControllerSystem,
    gravity_applier: GravityApplier,
    shape_painter: ShapePainter,
    velocity_applier: VelocityApplier,
    intersectable_update: IntersectableUpdate,
    intersectable_painter: IntersectablePainter,
    intersections_detector: IntersectionsDetector,
    intersections_painter: IntersectionsPainter
  }
}

local Game_State: GameState = {
  lander = {},
  {
    lander_ctrl_system = LanderControllerSystem.new(),
    gravity_applier = GravityApplier.new(),
    shape_painter = ShapePainter.new(),
    velocity_applier = VelocityApplier.new(),
    intersectable_update = IntersectableUpdate.new(),
    intersectable_painter = IntersectablePainter.new(),
    intersections_detector = IntersectionsDetector.new(),
    intersections_painter = IntersectionsPainter.new()
  }
}

function GameState:update_systems(entity: *Entity)
  self.systems.lander_ctrl_system.system.system_data:update(entity)

  self.systems.gravity_applier.system.system_data:update(entity)
  self.systems.shape_painter.system.system_data:update(entity)
  self.systems.velocity_applier.system.system_data:update(entity)
  self.systems.intersectable_update.system.system_data:update(entity)
  self.systems.intersectable_painter.system.system_data:update(entity)
  self.systems.intersections_detector.system.system_data:update(entity)
  self.systems.intersections_painter.system.system_data:update(entity)
end

function GameState:reset()
  local lander_ctrl = self.lander:get_lander_ctrl(RotorQuick.storages.lander_ctrl)
  lander_ctrl.state = LanderState.Flying

  local position = self.lander:get_position(RotorQuick.storages.position)
  position.position = Lander_Start_Position

  local velocity = self.lander:get_velocity(RotorQuick.storages.velocity)
  velocity:reset_velocity()

  local intersectable = self.lander:get_intersectable(RotorQuick.storages.intersectable)
  intersectable:set_global_rect(position.position)
end

function GameState:create_safe_landing(pos: Vector2)
  local safe_landing_shape: Shape = {
    category = Shape.ShapeCategory.Polygon,
    vertices = { {0, 0}, {16, 0}, {16, 16}, {0,16}, {0, 0} }
  }

  local safe_landing, safe_landing_entity = SafeLanding.new(
    RotorQuick.storages.entity,
    {
      --[[position       ]] { position = pos },
      --[[shape          ]] safe_landing_shape,
      --[[painter        ]] { color = SKYBLUE, active = true },
      --[[intersectable  ]] {},
      --[[is_safe_landing]] {}
    }
  )

  local intersectable = safe_landing:get_intersectable(RotorQuick.storages.intersectable)
  intersectable:identify(safe_landing.entity_id)
  intersectable:set_rects(pos, safe_landing_shape.vertices.data)

  self:update_systems(safe_landing_entity)
end

function GameState:create_floor(pos: Vector2)
  local floor_shape: Shape = {
    category = Shape.ShapeCategory.Polygon,
    vertices = { {0, 0}, {16, 0}, {16, 16}, {0,16}, {0, 0} }
  }

  local floor, floor_entity = Floor.new(
    RotorQuick.storages.entity,
    {
      --[[position     ]] { position = pos },
      --[[shape        ]] floor_shape,
      --[[painter      ]] { color = MAGENTA, active = true },
      --[[intersectable]] {},
      --[[is_floor     ]] {}
    }
  )

  local intersectable = floor:get_intersectable(RotorQuick.storages.intersectable)
  intersectable:identify(floor.entity_id)
  intersectable:set_rects(pos, floor_shape.vertices.data)

  self:update_systems(floor_entity)
end

local function _on_lander_intersect_enter(self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
  on_lander_intersect_enter(Game_State.lander, self_intersectable, self_intersections, other_intersectable)
end

local function _on_lander_intersect_exit(self_intersectable: *Intersectable, self_intersections: *Intersections, other_intersectable: *Intersectable)
  on_lander_intersect_exit(Game_State.lander, self_intersectable, self_intersections, other_intersectable)
end

function GameState:create_lander(pos: Vector2)
  local gravity_acceleration: number = 0.1

  local lander_shape: Shape = {
    category = Shape.ShapeCategory.Triangle,
    vertices = { {8, 0}, {0, 16}, {16, 16} }
  }

  local lander, lander_entity = Lander.new(
    RotorQuick.storages.entity,
    {
      --[[Position     ]] { position = pos },
      --[[Shape        ]] lander_shape,
      --[[Painter      ]] { color = WHITE, active = true },
      --[[Velocity     ]] { active = true, final_velocity = {0,0}, max_velocity = LANDER_MAX_VELOCITY, velocity_is_limited = true },
      --[[Gravity      ]] { acceleration = gravity_acceleration, direction = {0.0, 1.0}, active = true },
      --[[Intersectable]] {  },
      --[[Intersections]] { intersections = {}, on_enter_callback = _on_lander_intersect_enter, on_exit_callback = _on_lander_intersect_exit },

      --[[Lander Ctrl  ]] { propulsion_force = gravity_acceleration * 2.5, state = LanderState.Flying },
    }
  )

  local intersectable = lander:get_intersectable(RotorQuick.storages.intersectable)
  intersectable:identify(lander.entity_id)
  intersectable:set_rects(pos, lander_shape.vertices.data)

  self:update_systems(lander_entity)

  self.lander = lander
end

-- ]] Game State ]]

-- [[ Game Setup [[

Game_State:create_lander(LANDER_START_POSITION)

for i = 0, < 25 do
  for j = 17, < 21 do
    local is_safe_landing_tiles = i >= 19 and i <= 21 and j <= 18

    if not is_safe_landing_tiles then
      Game_State:create_floor({16*i, 16*j})
    else
      Game_State:create_safe_landing({16*i, 16*j})
    end
  end
end

-- ]] Game Setup ]]

-- [[ Main Loop [[

while not Raylib.WindowShouldClose() do
  if Raylib.IsKeyDown(KeyboardKey.KEY_R) then
    Game_State:reset()
  end

  local lander_ctrl = Game_State.lander:get_lander_ctrl(RotorQuick.storages.lander_ctrl)
  local is_flying = lander_ctrl.state == LanderState.Flying

  if is_flying then
    Game_State.systems.gravity_applier:run({&RotorQuick.storages.gravity, &RotorQuick.storages.velocity})
    Game_State.systems.lander_ctrl_system:run({&RotorQuick.storages.lander_ctrl, &RotorQuick.storages.velocity, &RotorQuick.storages.gravity})
    Game_State.systems.velocity_applier:run({&RotorQuick.storages.velocity, &RotorQuick.storages.position})
  end

  Game_State.systems.intersectable_update:run({&RotorQuick.storages.position, &RotorQuick.storages.intersectable})
  Game_State.systems.intersections_detector:run({&RotorQuick.storages.intersectable, &RotorQuick.storages.intersections})

  Raylib.BeginDrawing()
    Raylib.ClearBackground(BLACK)

    Game_State.systems.shape_painter:run({&RotorQuick.storages.position, &RotorQuick.storages.shape, &RotorQuick.storages.painter})
    Game_State.systems.intersectable_painter:run({&RotorQuick.storages.intersectable, &RotorQuick.storages.painter})
    Game_State.systems.intersections_painter:run({&RotorQuick.storages.intersections, &RotorQuick.storages.painter})

    if not is_flying then
      local msg = (do
        switch lander_ctrl.state
        case LanderState.Landed then
          return "You're Landed"
        case LanderState.Crashed then
          return "You Crashed"
        else
          return ""
        end
      end)

      local msg_fontsize <comptime> = 18
      local msg_width = Raylib.MeasureText(msg, msg_fontsize)
      Raylib.DrawText(msg, math.ifloor(screen_width / 2 - msg_width / 2), math.ifloor(screen_height / 2), msg_fontsize, WHITE)
    end

  Raylib.EndDrawing()
end
-- ]] Main Loop ]]

Raylib.CloseWindow()

--[[
asteroid = {
  position = {},
  velocity = {},
  asteroid_info = {},
  {
    shape = {},
    intersectable = {},
    shape2intersectable = {}
  },
  {
    shape = {},
    mesh = {},
    shape2mesh = {}.
  },
}

spaceship = {
  spaceship_controller = {},
  position = {},
  velocity = {},
  spaceship_info = {},
  {
    shape = {},
    intersectable = {},
    shape2intersectable = {}
    intersections = {},
  },
  {
    shape = {},
    mesh = {},
    shape2mesh = {}.
  },
}
]]
