-- [[ requires and imports [[

require 'math'

require 'raylib'
require 'rotor'
require 'rotor-quick'
require 'rotor-quick.makers'

local Position = RotorQuick.Components.Position
local Shape = RotorQuick.Components.Shape
local Painter = RotorQuick.Components.Painter
local Velocity = RotorQuick.Components.Velocity
local Gravity = RotorQuick.Components.Gravity
local Intersectable = RotorQuick.Components.Intersectable
local Intersections = RotorQuick.Components.Intersections

local GravityApplier = RotorQuick.Systems.GravityApplier
local ShapePainter = RotorQuick.Systems.ShapePainter
local VelocityApplier = RotorQuick.Systems.VelocityApplier
local IntersectableUpdate = RotorQuick.Systems.IntersectableUpdate
local IntersectablePainter = RotorQuick.Systems.IntersectablePainter
local IntersectionsDetector = RotorQuick.Systems.IntersectionsDetector
local IntersectionsPainter = RotorQuick.Systems.IntersectionsPainter

-- ]] requires and imports ]]

-- Main Game Record and general variables
local screen_width: integer <comptime> = 400
local screen_height: integer <comptime> = 300

local LunarLander = @record{}
global LunarLander.storages: record{} = {}
global LunarLander.masks: record {} = {}

-- [[ components [[

local LanderController = @record{
  propulsion_force: number
}
## is_component('lander_ctrl', LanderController)

-- ]] components ]]

-- [[ systems [[

global LanderControllerRunner = @record{}

function LanderControllerRunner:run(lander_ctrl: *LanderController, velocity: *Velocity, gravity: *Gravity, system_data: *SystemData)
  local is_right_down, is_up_down, is_left_down = Raylib.IsKeyDown(KeyboardKey.KEY_RIGHT),
                                                  Raylib.IsKeyDown(KeyboardKey.KEY_UP),
                                                  Raylib.IsKeyDown(KeyboardKey.KEY_LEFT)

  if is_right_down or is_up_down or is_left_down then
    --gravity.speed = 0

    local direction: Vector2 = {
      x = (do
        if is_right_down then
          return 1
        elseif is_left_down then
          return -1
        else
          return 0
        end
      end),

      y = (do
        if is_up_down then
          return -1
        else
          return 0
        end
      end)
    }

    velocity:add_velocity(direction * lander_ctrl.propulsion_force)
  end
end

local LanderControllerSystem = @MakeSystem(LanderControllerRunner, false, true, false, 1, @record{
  lander_ctrl: LanderController,
  velocity: Velocity,
  gravity: Gravity,
})

local lander_ctrl_system = LanderControllerSystem.new()

local gravity_applier = GravityApplier.new()
local shape_painter = ShapePainter.new()
local velocity_applier = VelocityApplier.new()
local intersectable_update = IntersectableUpdate.new()
local intersectable_painter = IntersectablePainter.new()
local intersections_detector = IntersectionsDetector.new()
local intersections_painter = IntersectionsPainter.new()

-- ]] systems ]]

-- [[ entities [[

local Lander = #[make_entity{
  {'position', Position},
  {'shape', Shape},
  {'painter', Painter},
  {'velocity', Velocity},
  {'gravity', Gravity},
  {'intersectable', Intersectable},
  {'intersections', Intersections},

  {'lander_ctrl', LanderController},
}]#

local function create_lander(pos: Vector2, gravity_acceleration: number)
  local lander_shape: Shape = {
    category = Shape.ShapeCategory.Triangle,
    vertices = { {8, 0}, {0, 16}, {16, 16} }
  }

  local lander, lander_entity = Lander.new(
    RotorQuick.storages.entity,
    {
      --[[Position     ]] { position = { pos.x, pos.y } },
      --[[Shape        ]] lander_shape,
      --[[Painter      ]] { WHITE, true },
      --[[Velocity     ]] { true, {0,0}, 0 },
      --[[Gravity      ]] { gravity_acceleration, {0.0, 1.0}, true },
      --[[Intersectable]] {  },
      --[[Intersections]] { {} },

      --[[Lander Ctrl  ]] { propulsion_force = gravity_acceleration * 2.5 },
    }
  )

  local intersectable = lander:get_intersectable(RotorQuick.storages.intersectable)
  intersectable:identify(lander.entity_id)
  intersectable:set_rects(pos, lander_shape.vertices.data)

  lander_ctrl_system.system.system_data:update(lander_entity)

  gravity_applier.system.system_data:update(lander_entity)
  shape_painter.system.system_data:update(lander_entity)
  velocity_applier.system.system_data:update(lander_entity)
  intersectable_update.system.system_data:update(lander_entity)
  intersectable_painter.system.system_data:update(lander_entity)
  intersections_detector.system.system_data:update(lander_entity)
  intersections_painter.system.system_data:update(lander_entity)
end

create_lander({32, 32}, 0.1)
create_lander({32, 32}, 0.0)

-- ]] entities ]]

Raylib.SetConfigFlags(ConfigFlag.FLAG_WINDOW_RESIZABLE)
Raylib.InitWindow(screen_width, screen_height, "raylib [core] example - basic window")
Raylib.SetTargetFPS(60)

while not Raylib.WindowShouldClose() do
  gravity_applier:run({&RotorQuick.storages.gravity, &RotorQuick.storages.velocity})
  lander_ctrl_system:run({&RotorQuick.storages.lander_ctrl, &RotorQuick.storages.velocity, &RotorQuick.storages.gravity})
  velocity_applier:run({&RotorQuick.storages.velocity, &RotorQuick.storages.position})

  intersectable_update:run({&RotorQuick.storages.position, &RotorQuick.storages.intersectable})
  intersections_detector:run({&RotorQuick.storages.intersectable, &RotorQuick.storages.intersections})

  Raylib.BeginDrawing()
    Raylib.ClearBackground(BLACK)

    shape_painter:run({&RotorQuick.storages.position, &RotorQuick.storages.shape, &RotorQuick.storages.painter})
    intersectable_painter:run({&RotorQuick.storages.intersectable, &RotorQuick.storages.painter})
    intersections_painter:run({&RotorQuick.storages.intersections, &RotorQuick.storages.painter})

  Raylib.EndDrawing()
end

Raylib.CloseWindow()

--[[
asteroid = {
  position = {},
  velocity = {},
  asteroid_info = {},
  {
    shape = {},
    intersectable = {},
    shape2intersectable = {}
  },
  {
    shape = {},
    mesh = {},
    shape2mesh = {}.
  },
}

spaceship = {
  spaceship_controller = {},
  position = {},
  velocity = {},
  spaceship_info = {},
  {
    shape = {},
    intersectable = {},
    shape2intersectable = {}
    intersections = {},
  },
  {
    shape = {},
    mesh = {},
    shape2mesh = {}.
  },
}
]]
