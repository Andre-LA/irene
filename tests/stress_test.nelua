-- inspired from: https://github.com/Tjakka5/love-ecs-benchmarks

-- require everything
require 'nene'
require 'rotor'
require 'irene'

-- set window size
local win_w <comptime>, win_h <comptime> = 800, 600

-- tracks entity count
local entity_count = 0

-- comptime options, use -D to set them
local E_LIMIT <comptime> = #[E_LIMIT or 50000]#
local NO_DRAW <comptime> = #[NO_DRAW or false]#

-- walker component
local WalkerComp = @record{ a: byte }
## Irene.impl_is_component(WalkerComp)

-- walker entity
-- the data of Walker type is a collection of GenerationalIndex ids
-- of each component, curiously, Walker is also a component and always included
-- on the entities created from it
local Walker = @MakeEntity('walker',
  Irene.Comps.Position,
  Irene.Comps.Shape,
  Irene.Comps.Painter,
  Irene.Comps.Velocity,
  WalkerComp
)

-- walker system
-- a system is a loop that iterate on all entities that contains the specified components,
-- in other words, a filter.
-- here we make a system that requires position, walker_comp and walker
local WalkerSystem = @MakeSystem('WalkerSystem', @record{
  position: Irene.Comps.Position,
  walker_comp: WalkerComp,
  walker: Walker, -- yes, we can require the entity's "id collection" type, which is always included by default
})

-- the actual function that runs the system
function WalkerSystem:run()

  for _, components in self:iterate_components() do
    -- copy **references** from each component
    local position = components.position
    local walker = components.walker_comp
    local walker_ids = components.walker

    -- then just a very standard gameplay code
    local beywond_width = position.local_position.x > win_w
    local beywond_height = position.local_position.y > win_h

    if beywond_width or beywond_height then
      if math.random() > 0.6 then -- 60% of chance to be conserved, 40% to be destroyed
        if beywond_width then
          position.local_position.x = 0
        end

        if beywond_height then
          position.local_position.y = 0
        end
      else -- then destroy
        -- for each component of Walker, we need to free the entry for it's respective storage
        Irene.storages.position:remove_entry(walker_ids.position_id)
        Irene.storages.painter:remove_entry(walker_ids.painter_id)
        Irene.storages.velocity:remove_entry(walker_ids.velocity_id)
        Irene.storages.walker_comp:remove_entry(walker_ids.walker_comp_id)

        -- the shape component contains a `vector` inside, which is allocated, so we need to free
        -- the previously allocated memory, otherwise it will leak
        Irene.storages.shape:remove_entry(walker_ids.shape_id, Irene.Comps.Shape.destroy)

        -- finally, remove the entity, an destroy method also needs to be passed as argument
        Irene.storages.entity:remove_entry(walker_ids.entity_id, Entity.destroy)

        entity_count = entity_count - 1
      end
    end
  end
end

---- runtime code ----

-- initialize nene
local ok, nene = Nene.init('create and delete entities', win_w, win_h)
defer nene:terminate() end

-- initialize systems
local shape_painter = Irene.Sys.ShapePainter.new()
local velocity_applier = Irene.Sys.VelocityApplier.new()
local walker_system = WalkerSystem.new()

defer
  shape_painter:destroy()
  velocity_applier:destroy()
  walker_system:destroy()
end

-- function to create a walker entity more easily
local function create_walker(): Walker
  local walker, walker_e = Walker.new {
    position = {},
    shape = {
      category = Irene.Comps.Shape.ShapeCategory.Rectangle,
      vertices = { {0, 0}, {4, 0}, {4, 4}, {0, 4} }
    },
    painter = {
      active = true,
      color = Color.Palette.yellow,
    },
    velocity = {
      active = true,
      final_velocity = {math.random()*4, math.random()*4},
    },
  }

  shape_painter.system_data:update(walker_e)
  velocity_applier.system_data:update(walker_e)
  walker_system.system_data:update(walker_e)

  entity_count = entity_count + 1

  return walker
end

-- game code
local function stress_test()
  -- game loop
  repeat
    -- update pass:

    -- update nene state
    nene:poll_events()

    -- create 100 walkers while don't reach limit
    if entity_count < E_LIMIT then
      for _ = 1, 100 do
        create_walker()
      end
    end

    -- run velocity and walker systems
    velocity_applier:run()
    walker_system:run()

    -- draw pass:

    -- clear background
    nene:render_clear(Color.Palette.bg)

    ## if not NO_DRAW then
      -- draw all shapes
      shape_painter:run(nene)
    ## end

    -- present all rendered things
    nene:render_present()

    print('entity_count', entity_count, nene.delta_time)

  -- run game until nene asks to quit
  until nene.quit
end

stress_test()
