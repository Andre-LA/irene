--[[ This Source Code Form is subject to the terms of the Mozilla Public
     License, v. 2.0. If a copy of the MPL was not distributed with this
     file, You can obtain one at https://mozilla.org/MPL/2.0/. ]]

require 'math'
require 'gamemath'
require 'quicktypes'
require 'quickgamelib'
require 'vector'

-- is possible to only require the used records by not requiring any init:
require 'rotor-quick.core'
require 'rotor-quick.components.intersectable'

local RQ_Comps = RotorQuick.Components

local quad: vector(GameMath.Vec2) = {
  (@GameMath.Vec2){ 0,  0},
  (@GameMath.Vec2){32,  0},
  (@GameMath.Vec2){32, 32},
  (@GameMath.Vec2){ 0, 32}
}

local a: RQ_Comps.Intersectable = {}
a:init({}, {32,32}, quad.data)

local b: RQ_Comps.Intersectable = {}
b:init({}, {128,128}, quad.data)

-- main:
local ok, err_msg, core_state = QuickGame.init("Intersection test", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 640, 380, SDL_WINDOW_SHOWN)
check(ok, err_msg)

local mx: integer, my: integer;

while not core_state.quit do -- main loop
  core_state:pool_events{
    on_quit_event = nilptr,
    on_key_event = nilptr,
    on_mousemotion_event = function(mousemotion_evt: SDL_MouseMotionEvent)
      mx = mousemotion_evt.x
      my = mousemotion_evt.y
    end
  }

  a:set_global_rect({mx, my})

  local intersection, is_intersecting = a:get_intersection(b)

  core_state:render_clear(QuickGame.PALLETE.BG) -- clear screen with color
  do
    local text = is_intersecting and 'is intersecting' or 'is not intersecting'

    --tico.graphics_draw_text(text, 0, 0, tico.WHITE)

    core_state:render_draw_rect(a.global_rect:to_rect(), false, QuickGame.PALLETE.WHITE)
    core_state:render_draw_rect(b.global_rect:to_rect(), false, QuickGame.PALLETE.WHITE)

    if is_intersecting then
      core_state:render_draw_rect(intersection:to_rect(), false, QuickGame.PALLETE.RED)
    end
  end
  core_state:render_present()
end

core_state:terminate()
