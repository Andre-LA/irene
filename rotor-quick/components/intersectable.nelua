require 'span'
require 'math'
require 'gamemath'
require 'rotor-quick.makers'

global RotorQuick.Components.Intersectable = @record{
  local_rect: GameMath.Rectf,
  global_rect: GameMath.Rectf,
  entity_id: GenerationalIndex,
}

local Intersectable = RotorQuick.Components.Intersectable
## is_component(Intersectable)

local function _gen_intersection_coords(self_rect: *GameMath.Rectf, other_rect: *GameMath.Rectf): (GameMath.Vec2, GameMath.Vec2)
  local max_x = math.max(self_rect.x, other_rect.x)
  local max_y = math.max(self_rect.y, other_rect.y)
  local min_xw = math.min(self_rect.x + self_rect.w, other_rect.x + other_rect.w)
  local min_yh = math.min(self_rect.y + self_rect.h, other_rect.y + other_rect.h)

  return (@GameMath.Vec2){ max_x, max_y }, (@GameMath.Vec2){ min_xw, min_yh }
end

local function _is_point_inside_rect(p: *GameMath.Vec2, rect: *GameMath.Rectf): boolean
  return p.x >= rect.x and p.x <= rect.x + rect.w and p.y >= rect.y and p.y <= rect.y + rect.h
end

function Intersectable.rect_from_vertices(vertices: *span(GameMath.Vec2)): GameMath.Rectf
  local min_x, min_y, max_x, max_y = 0.0, 0.0, 0.0, 0.0

  for i = 0, < #vertices do
    min_x = math.min(vertices[i].x, min_x)
    max_x = math.max(vertices[i].x, max_x)

    min_y = math.min(vertices[i].y, min_y)
    max_y = math.max(vertices[i].y, max_y)
  end

  return (@GameMath.Rectf){
    min_x, min_y,
    max_x, max_y
  }
end

function Intersectable.get_global_rect(rect: GameMath.Rectf, pos: GameMath.Vec2): GameMath.Rectf
  rect.x = rect.x + pos.x
  rect.y = rect.y + pos.y
  return rect
end

function Intersectable:set_global_rect(pos: GameMath.Vec2)
  self.global_rect = Intersectable.get_global_rect(self.local_rect, pos)
end

function Intersectable:set_rects(pos: GameMath.Vec2, vertices: *span(GameMath.Vec2))
  self.local_rect = Intersectable.rect_from_vertices(vertices)
  self:set_global_rect(pos)
end

function Intersectable:is_intersecting(other: overload(*Intersectable, *GameMath.Rectf, GameMath.Vec2)): boolean
  --return true
  ## if other.type.is_pointer then -- can be an Intersectable or GameMath.Rectf
    local other_rect: GameMath.Rectf = {}

    ## if other.type.subtype.is_intersectable then -- is an Intersectable
      other_rect = other.global_rect
    ## else -- is a GameMath.Rectf
      other_rect = other
    ## end

    local pmin = _gen_intersection_coords(self.global_rect, other_rect)
    return _is_point_inside_rect(pmin, self.global_rect) and _is_point_inside_rect(pmin, other_rect)
  ## else -- is a GameMath.Vec2
    return _is_point_inside_rect(other, self.global_rect)
  ## end
end

function Intersectable:get_intersection(other_intersectable: *Intersectable): (GameMath.Rectf, boolean)
  local result: GameMath.Rectf = {}
  local is_intersecting = self:is_intersecting(other_intersectable)

  if is_intersecting then
    local pmin, pmax = _gen_intersection_coords(self.global_rect, other_intersectable.global_rect)
    result = { x = pmin.x, y = pmin.y, w = math.abs(pmax.x - pmin.x), h = math.abs(pmax.y - pmin.y)}
  end

  return result, is_intersecting
end

function Intersectable:init(entity_id: GenerationalIndex, pos: GameMath.Vec2, vertices: *span(GameMath.Vec2))
  self.entity_id = entity_id
  self:set_rects(pos, vertices)
end
