require 'span'
require 'math'
require 'nene.math'
require 'rotor-quick.makers'

global RotorQuick.Components.Intersectable = @record{
  local_rect: Nene.Math.Rectf,
  global_rect: Nene.Math.Rectf,
  entity_id: GenerationalIndex,
}

local Intersectable = RotorQuick.Components.Intersectable
## is_component(Intersectable)

function Intersectable.rect_from_vertices(vertices: *span(Nene.Math.Vec2)): Nene.Math.Rectf
  local min_x, min_y, max_x, max_y = 0.0, 0.0, 0.0, 0.0

  for i = 0, < #vertices do
    min_x = math.min(vertices[i].x, min_x)
    max_x = math.max(vertices[i].x, max_x)

    min_y = math.min(vertices[i].y, min_y)
    max_y = math.max(vertices[i].y, max_y)
  end

  return (@Nene.Math.Rectf){
    min_x, min_y,
    max_x, max_y
  }
end

function Intersectable.get_global_rect(rect: Nene.Math.Rectf, pos: Nene.Math.Vec2): Nene.Math.Rectf
  rect.x = rect.x + pos.x
  rect.y = rect.y + pos.y
  return rect
end

function Intersectable:set_global_rect(pos: Nene.Math.Vec2)
  self.global_rect = Intersectable.get_global_rect(self.local_rect, pos)
end

function Intersectable:set_rects(pos: Nene.Math.Vec2, vertices: *span(Nene.Math.Vec2))
  self.local_rect = Intersectable.rect_from_vertices(vertices)
  self:set_global_rect(pos)
end

function Intersectable:is_intersecting(other: overload(*Intersectable, *Nene.Math.Rectf, Nene.Math.Vec2)): boolean
  ## if other.type.is_pointer then -- can be an Intersectable or Nene.Math.Rectf
    local other_rect: Nene.Math.Rectf = {}

    ## if other.type.subtype.is_intersectable then -- is an Intersectable
      other_rect = other.global_rect
    ## else -- is a Nene.Math.Rectf
      other_rect = other
    ## end

    return self.global_rect:is_rect_intersecting(other_rect)
  ## else -- is Nene.Math.Vec2
    return self.global_rect:is_point_intersecting(other)
  ## end
end

function Intersectable:get_intersection(other_intersectable: *Intersectable): (Nene.Math.Rectf, boolean)
  local intersection = self.global_rect:get_intersection(other_intersectable.global_rect)
  local is_intersecting = self.global_rect:is_rect_intersecting(other_intersectable.global_rect)
  return intersection, is_intersecting
end

function Intersectable:init(entity_id: GenerationalIndex, pos: Nene.Math.Vec2, vertices: *span(Nene.Math.Vec2))
  self.entity_id = entity_id
  self:set_rects(pos, vertices)
end
