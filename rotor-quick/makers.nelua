require 'rotor-quick'
## local metalib = require 'rotor-quick.metalib'

## if PROF then
  require 'nprof'
  global nprof: NProf = {}
## end

##[[
  local function is_record(_type)
    return metalib.basic_typecheck(_type, 'record', function(value)
      if _type and _type.value and traits.is_type(_type.value) and _type.value.is_record then
        return true
      else
        tostring(_type)
      end
    end)
  end
]]

-- [[ mark record as component [[

##[[
  local masks_count = 0

  is_component = hygienize(function(compname, T)
    T.value.is_component = true
    RQ_add_mask_and_storage(compname, T)
  end)
]]
-- ]] mark record as component ]]

-- [[ Entity maker [[
## make_entity = hygienize(function(components) -- components "shape": { string:NeluaRecord }, example: { type_name = TypeName }
  ##[[
    local function gen_errmsg(comp_type, err_msg)
      local comp_name, comp_name_snakecase = comp_type.name, metalib.pascalcase_to_snakecase(comp_type.name)
      return string.format(
        'assertion error with type %s: %s. Maybe you forgot to use ## is_component(%s, %s)?',
        comp_name,
        err_msg,
        comp_name_snakecase,
        comp_name
      )
    end

    local function assert_type_is_component(comp_type)
      staticassert(is_record(comp_type))

      local c_type, err_msg = metalib.basic_typecheck(comp_type.value, "record with 'is_component' trait", function(value)
        local is_type = traits.is_type(value)
        local is_record = is_type and value.is_record
        local is_component = is_record and value.is_component

        if is_component then
          return true
        elseif is_record then
          return "record without 'is_component' trait"
        else
          return tostring(value)
        end
      end)

      staticassert(c_type, gen_errmsg(comp_type, err_msg)) -- does assertion failure when ## is_component wasn't used

      return comp_type
    end
  ]]

  local NewEntityType = @record{ entity_id: GenerationalIndex }
  local InitialValuesCollection = @record{}

  ## for i = 1, #components do
    ##[[
      local comp_type = assert_type_is_component(components[i])
      local comp_name = metalib.pascalcase_to_snakecase(comp_type.name)

      local name_id = comp_name..'_id'
      local name_vl = comp_name..'_vl'
      local get_name =  'get_'..comp_name
    ]]

    ## NewEntityType.value:add_field(name_id, GenerationalIndex.value)
    ## InitialValuesCollection.value:add_field(name_vl, comp_type.value)

    function NewEntityType:#|get_name|#(storage: pointer(Storage(#[comp_type.value]#))): pointer(#[comp_type.value]#)
      local possible_result = storage:get_entry(self.#|name_id|#)
      check(possible_result.filled, #[comp_name .. ' is not associated with entity!']#)
      local result = possible_result:get()
      return result
    end
  ## end

  function NewEntityType.new(entity_storage: *Storage(Entity), values: InitialValuesCollection): (NewEntityType, *Entity)
    local result: NewEntityType = {}

    local entity_id, entity = entity_storage:new_entry(Entity.new())
    result.entity_id = entity_id

    ## for i = 1, #components do
      ##[[
        local comp_type = assert_type_is_component(components[i])
        local comp_name = metalib.pascalcase_to_snakecase(comp_type.name)

        local name_id = comp_name..'_id'
        local name_vl = comp_name..'_vl'
      ]]

      local #|name_id|#, #|name_vl|# = RotorQuick.storages.#|comp_name|#:new_entry(values.#|name_vl|#)
      entity:associate(#|name_id|#, RotorQuick.masks.#|comp_name|#)

      result.#|name_id|# = #|name_id|#
    ## end

    return result, entity
  end

  ## return NewEntityType
## end)

-- ]] Entity maker ]]

-- [[ system maker [[
global System = @record{
  read: vector(BitsetArray),
  write: vector(BitsetArray),
  system_data: SystemData,
}

## local make_system = generalize(function(T, use_before, use_run, use_after, read_count, run_T)
  ##[[
    staticassert(traits.is_type(T), "invalid type %s", T)

    local component_names = {}
    local component_types = {}

    for _, field in ipairs(run_T.fields) do
      local ftype = field.type
      staticassert(traits.is_type(ftype) and ftype.is_component, 'type %s is not a component!', ftype)

      table.insert(component_names, field.name)
      table.insert(component_types, ftype)
    end

    local read_names = table.move(component_names, 1, read_count, 1, {})
    local read_types = table.move(component_types, 1, read_count, 1, {})

    local write_names = table.move(component_names, read_count+1, #component_names, 1, {})
    local write_types = table.move(component_types, read_count+1, #component_names, 1, {})
  ]]

  local T = @#[T]#

  local optCollectionT = @record{}
  local storagesCollectionT = @record{}

  ## for i, name in ipairs(component_names) do
    local opt_T = @optional(*#[ component_types[i] ]#)
    ## optCollectionT.value:add_field(name, opt_T.value)

    local stor_T = @pointer(Storage( #[ component_types[i] ]# ))
    ## storagesCollectionT.value:add_field(name, stor_T.value)
  ## end

  local systemT <nickname #[string.format('system(%s)', T)]#> = @record{
    system: System,
    opts: optCollectionT,
    runner: T,
  }

  ## systemT.value.subtype = T

  function systemT.new(): systemT
    local new_system: systemT = {}

    new_system.system.read:reserve(#[#read_names]#)
    new_system.system.write:reserve(#[#read_names]#)

    ## for i, name in ipairs(read_names) do
      new_system.system.read:push(bitset_array.copy(RotorQuick.masks.#|name|#))
    ## end

    ## for i, name in ipairs(write_names) do
      new_system.system.write:push(bitset_array.copy(RotorQuick.masks.#|name|#))
    ## end

    new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
    return new_system
  end

  function systemT:verify(): boolean
    local values: array(boolean, #[ #component_names]#) = {}
    local result: boolean = true

    ## for i, name in ipairs(component_names) do
      values[#[i-1]#] = self.opts.#|name|#.filled
    ## end

    for i = 0, < #[#component_names]# do
      result = result and values[i]
    end

    return result
  end

  function systemT:run(storages: storagesCollectionT)
    ## if PROF then
      nprof:push(#[systemT.value.nickname]#)
      defer nprof:pop() end
    ## end

    local runner: *T = self.runner

    ## if use_before then
      runner:before_all(self.system.system_data)
    ## end

    ## if use_run then
      local system_data: *SystemData = self.system.system_data

      for i = 0, < #system_data.components_indexes do
        local ids = system_data.components_indexes[i]

        if #ids > 0 then
          ## for i, name in ipairs(component_names) do
            ## local name_id = name..'_id'
            local #|name_id|# = ids[#[i-1]#]
            self.opts.#|name|# = storages.#|name|#:get_entry(#|name_id|#)
          ## end

          if self:verify() then
             ## for _, name in ipairs(component_names) do
               local #|name|# = self.opts.#|name|#:get()
             ## end

            ##[[
              local ids = metalib.create_id_nodes(aster, component_names)

              table.insert(ids, aster.Id{'system_data'})
              table.insert(ids, 1, aster.Id{'runner'})

              inject_astnode(metalib.create_call_node(aster, T, 'run', table.unpack(ids)))
            ]]
          else
            self.system.system_data:mark_available(i)
          end
        end
      end
    ## end

    ## if use_after then
      runner:after_all(self.system.system_data)
    ## end
  end

  function systemT:update(entity: *Entity)
    self.system.system_data:update(entity)
  end

  ## return systemT
## end)

global MakeSystem = #[make_system]#

-- ]] system maker ]]
