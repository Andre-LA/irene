require 'math'
require 'nene'
require 'rotor'
require 'rotor-quick.makers'
require 'rotor-quick.components.position'
require 'rotor-quick.components.shape'
require 'rotor-quick.components.painter'

local RQ_Comps = RotorQuick.Components

global RotorQuick.Systems.ShapePainter = @MakeSystem('ShapePainter', @record{
  position: RQ_Comps.Position,
  shape: RQ_Comps.Shape,
  painter: RQ_Comps.Painter
})

local ShapePainter = RotorQuick.Systems.ShapePainter

function ShapePainter:run(core_state: *Nene.CoreState)
  ## if PROF then
    nprof:push(#[ShapePainter.value.nickname]#)
    defer nprof:pop() end
  ## end

  for _, components in self:iterate_components() do
    local position = components.position
    local shape = components.shape
    local painter = components.painter

    if not painter.active then
      continue
    end

    local size_x, size_y = 0.0, 0.0

    for i = 0, < #shape.vertices do
      size_x = math.max(shape.vertices[i].x, size_x)
      size_y = math.max(shape.vertices[i].y, size_y)
    end

    local global_pos = position:get_global_position()

    local ShapeCategory = RQ_Comps.Shape.ShapeCategory

    switch shape.category
    case ShapeCategory.Rectangle then
      local rectf: Nene.Math.Rectf = { global_pos.x, global_pos.y, size_x, size_y }
      core_state:render_draw_rect(rectf:to_rect(), painter.use_lines, painter.color)

    case ShapeCategory.Circle then
      --tico.graphics_fill_circle(
      --  math.ifloor(global_pos.x),
      --  math.ifloor(global_pos.y),
      --  math.max(size_x, size_y) / 2,
      --  painter.color
      --)

    case ShapeCategory.Triangle then
      local p1, p2, p3 = shape.vertices[0], shape.vertices[1], shape.vertices[2]
      core_state:render_draw_line(global_pos + p1, global_pos + p2, painter.color)
      core_state:render_draw_line(global_pos + p2, global_pos + p3, painter.color)
      core_state:render_draw_line(global_pos + p3, global_pos + p1, painter.color)

    case ShapeCategory.Polygon then
      for i = 0, < #shape.vertices - 1 do

        core_state:render_draw_line(global_pos + shape.vertices[i],
                                    global_pos + shape.vertices[i+1],
                                    painter.color)
      end
      core_state:render_draw_line(global_pos + shape.vertices[#shape.vertices-1],
                                  global_pos + shape.vertices[0],
                                  painter.color)
    end
  end
end

