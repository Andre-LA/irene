require 'math'
require 'raylib'
require 'rotor'
require 'rotor-quick.makers'
require 'rotor-quick.components.position'
require 'rotor-quick.components.shape'
require 'rotor-quick.components.painter'

local Position = RotorQuick.Components.Position
local Painter = RotorQuick.Components.Painter

local Shape = RotorQuick.Components.Shape
local ShapeCategory = Shape.ShapeCategory

global  ShapePainterRunner = @record{}

function ShapePainterRunner:run(position: *Position, shape: *Shape, painter: *Painter, system_data: *SystemData)
  if not painter.active then
    return
  end

  local size_x, size_y = 0.0, 0.0

  for i = 0, < #shape.vertices do
    size_x = math.max(shape.vertices[i][0], size_x)
    size_y = math.max(shape.vertices[i][1], size_y)
  end

  switch shape.category do
  case ShapeCategory.Rectangle then
    Raylib.DrawRectangleV(position.position, {size_x, size_y}, painter.color)
  case ShapeCategory.Circle then
    Raylib.DrawCircleV(position.position, math.max(size_x, size_y) / 2, painter.color)
  case ShapeCategory.Polygon then
    local points: vector(Vector2)
    points:reserve(#shape.vertices)
    defer points:destroy() end

    for i = 0, < #shape.vertices do
      points:push({ position.position.x + shape.vertices[i][0], position.position.y + shape.vertices[i][1] })
    end

    points:push({ position.position.x + shape.vertices[0][0], position.position.y + shape.vertices[0][1] })

    Raylib.DrawLineStrip(&points.data[0], #points, painter.color)
  end
end

global RotorQuick.Systems.ShapePainter = @MakeSystem(ShapePainterRunner, false, true, false, 3, @record{
  position: Position,
  shape: Shape,
  painter: Painter,
})
