require 'rotor-quick.components.collider'
require 'rotor-quick.components.velocity'
require 'rotor-quick.components.intersections'
require 'rotor-quick.components.intersectable'
require 'rotor-quick.components.position'
require 'rotor-quick.makers'

local Collider = RotorQuick.Components.Collider
local Velocity = RotorQuick.Components.Velocity
local Intersections = RotorQuick.Components.Intersections
local Intersectable = RotorQuick.Components.Intersectable
local Position = RotorQuick.Components.Position

global RotorQuick.Systems.Collisions = @MakeSystem('Collisions', @record{
  collider: Collider,
  velocity: Velocity,
  intersections: Intersections,
  intersectable: Intersectable,
  position: Position,
})

local Collisions = RotorQuick.Systems.Collisions

local function limit_velocity_axis(stop_decreasing: boolean, vel_axis: *number)
  if stop_decreasing then
    if $vel_axis < 0 then
      $vel_axis = 0
    end
  else
    if $vel_axis > 0 then
      $vel_axis = 0
    end
  end
end

function Collisions:run()
  ## if PROF then
    nprof:push(#[Collisions.value.nickname]#)
    defer nprof:pop() end
  ## end

  for _, components in self:iterate_components() do
    local collider = components.collider
    local velocity = components.velocity
    local intersections = components.intersections
    local intersectable = components.intersectable
    local position = components.position

    local my_rect_center = intersectable.global_rect:get_center()

    for i, intersection in ipairs(intersections.intersections) do
      local can_collide = collider.mask & intersection.mask ~= 0

      if can_collide then
        if intersection.rect.w < collider.tolerance and intersection.rect.h < collider.tolerance then
          continue
        end

        local intersection_center = intersection.rect:get_center()
        local centers_diff = intersection_center - my_rect_center

        if centers_diff.x > -0.001 and centers_diff.x < 0.001 and centers_diff.y > -0.001 and centers_diff.y < 0.001 then
          continue
        end

        local w_to_h_ratio = intersection.rect.w / intersection.rect.h

        local intersection_on_left = centers_diff.x > 0
        local intersection_on_top = centers_diff.y < 0

        local x_rect_surface = intersection.rect.x + (intersection_on_left and -intersectable.global_rect.w or intersection.rect.w)
        local y_rect_surface = intersection.rect.y + (intersection_on_top and intersection.rect.h or -intersectable.global_rect.h)

        if w_to_h_ratio < 0.999 then -- rect is vertical
          limit_velocity_axis(not intersection_on_left, &velocity.final_velocity.x)
          position:set_local_from_global({x_rect_surface, position:get_global_position().y})

        elseif w_to_h_ratio > 1.001 then -- rect is horizontal
          limit_velocity_axis(intersection_on_top, &velocity.final_velocity.y)
          position:set_local_from_global({position:get_global_position().x, y_rect_surface})

        else -- the intersection is on the rect's corners
          limit_velocity_axis(intersection_on_left, &velocity.final_velocity.x)
          limit_velocity_axis(intersection_on_top, &velocity.final_velocity.y)

          position:set_local_from_global({x_rect_surface, y_rect_surface})
        end
      end
    end
  end
end
