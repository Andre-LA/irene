require 'math'
require 'raylib'
require 'rotor'
require 'rotor-quick.makers'
require 'rotor-quick.components.position'
require 'rotor-quick.components.shape'
require 'rotor-quick.components.painter'

local Velocity = RotorQuick.Components.Velocity
local Position = RotorQuick.Components.Position

global RotorQuick.Systems.VelocityApplier = @MakeSystem('VelocityApplier', @record{
  velocity: Velocity,
  position: Position,
})

local VelocityApplier = RotorQuick.Systems.VelocityApplier

function VelocityApplier:run()
  ## if PROF then
    nprof:push(#[VelocityApplier.value.nickname]#)
  ## end

  for _, components in self:iterate_components() do
    local velocity: *Velocity = components.velocity
    local position: *Position = components.position

    if not velocity.active then
      return
    end

    if velocity.velocity_is_limited then
      velocity.final_velocity = Velocity.get_limited_velocity(velocity.final_velocity, velocity.max_velocity)
    end

    -- TODO (discussion): Should Î”t be used? (see: https://github.com/Andre-LA/rotor-quick/issues/1)
    position.local_position.x = position.local_position.x + velocity.final_velocity.x
    position.local_position.y = position.local_position.y + velocity.final_velocity.y
  end

  ## if PROF then
    nprof:pop()
  ## end
end

