require 'nene'
require 'gamemath'

require 'math'

require 'rotor-quick.makers'
require 'rotor-quick.components.position'
require 'rotor-quick.components.sprite'
require 'rotor-quick.components.painter'

local RQ_Comps = RotorQuick.Components

local EachRunIds = @record{
  position_id: GenerationalIndex,
  painter_id: GenerationalIndex,
  sprite_id: GenerationalIndex,
}

global RotorQuick.Systems.SpritePainter = @MakeSystem('SpritePainter', @record{
  position: RQ_Comps.Position,
  painter: RQ_Comps.Painter,
  sprite: RQ_Comps.Sprite
})

local SpritePainter = RotorQuick.Systems.SpritePainter

-- vector of layers, each layer is a vector of the triple of ids to components of each iterated entity
local DrawOrder: type = @vector(vector(EachRunIds))
## SpritePainter.value:add_field('draw_order', DrawOrder.value)

function SpritePainter:run(core_state: *Nene.CoreState)
  ## if PROF then
    nprof:push(#[SpritePainter.value.nickname]#)
    defer nprof:pop() end
  ## end

  defer
    for i = 0, < #self.draw_order do
      self.draw_order[i]:destroy()
    end
    self.draw_order:destroy()
  end

  -- collect ids of the components to iterate
  for i = 0, < #self.system_data.components_indexes do
    local ids = self.system_data.components_indexes[i]

    if #ids > 0 then
      local position_id = ids[0]
      local painter_id = ids[1]
      local sprite_id = ids[2]

      local position_opt = RotorQuick.storages.position:get_entry(position_id)
      local painter_opt = RotorQuick.storages.painter:get_entry(painter_id)
      local sprite_opt = RotorQuick.storages.sprite:get_entry(sprite_id)

      if position_opt.filled and painter_opt.filled and sprite_opt.filled then
        local painter: *RQ_Comps.Painter = painter_opt:get()

        if painter.active then
          local sprite: *RQ_Comps.Sprite = sprite_opt:get()

          if #self.draw_order <= sprite.layer then
            self.draw_order:resize(sprite.layer + 1)
          end

          self.draw_order[sprite.layer]:push({ position_id, painter_id, sprite_id })
        end
      else
        self.system_data:mark_available(i)
      end
    end
  end

  for i = 0, < #self.draw_order do
    local current_layer = self.draw_order[i]

    for j = 0, < #current_layer do
      local position_opt = RotorQuick.storages.position:get_entry(current_layer[j].position_id)
      local painter_opt = RotorQuick.storages.painter:get_entry(current_layer[j].painter_id)
      local sprite_opt = RotorQuick.storages.sprite:get_entry(current_layer[j].sprite_id)

      local position: *RQ_Comps.Position = position_opt:get()
      local painter: *RQ_Comps.Painter = painter_opt:get()
      local sprite: *RQ_Comps.Sprite = sprite_opt:get()

      local drawpos = position:get_global_position() + sprite.offset
      local spritesheet = $sprite.spritesheet
      core_state:render_draw_atlas_frame(spritesheet, sprite.current_frame, drawpos, painter.color)
    end
  end
end

