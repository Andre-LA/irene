--[[
Tiled Map Loader library, an utility that helps creating tilemaps and objects by reading a json
file exported from Tiled using the irene_export extension (it's on the `utils` directory
in the root path of the project).

> Note: It's recommended to only use this library for fast iteration during development;
        this library is not ready to deal with untrusted sources and it's runtime-only, if possible
        use the lua export of Tiled and use `arrmap` and `map_caller` libraries in order to
        import maps at compile-time.
]]

--[[
  Copyright (c) 2020-2022 AndrÃ© Luiz Alvares

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at https://mozilla.org/MPL/2.0/.

  SPDX-License-Identifier: MPL-2.0
]]

-- nelua
local io = require 'io'
local vector = require 'vector'
local hashmap = require 'hashmap'
require 'iterators'

-- nelua-batteries
local json = require 'json'

-- nene
local Tilemap = require 'nene.tilemap'

-- tile map loader
local TiledMapLoader = @record{}

local TileLayerData = @record{
  name: string,
  width: uinteger,
  height: uinteger,
  data: vector(integer),
}

local ObjectData = @record{
  name: string,
  class_name: string,
  pos: record{ x: number, y: number },
  properties: hashmap(string, integer),
}

local ObjectLayerData = @record{
  name: string,
  objects: vector(ObjectData),
}

local MapData = @record{
  width: uinteger,
  height: uinteger,
  tile_layers: vector(TileLayerData),
  object_layers: vector(ObjectLayerData),
}

local function find_named_layer(
  name: string,
  layers: overload( *vector(TileLayerData), *vector(ObjectLayerData) )
): (boolean, pointer(#[layers.type.subtype.subtype]#))

  for _, layer in mipairs(layers) do
    if layer.name == name then
      return true, layer
    end
  end

  return false
end

function TiledMapLoader.load_map_file(filepath: string): (boolean, MapData, string)
  ## local function check_and_return_on_error(extra_err)
    check(#err == 0, err)
    if #err > 0 then return false, (@MapData)(), err end
  ## end

  local file <close>, err = io.open(filepath)
  ## check_and_return_on_error()

  local file_content, err = file:read('a')
  ## check_and_return_on_error()

  local data, err, chars_parsed = json.parse(file_content, MapData)
  ## if IRENE_EXTENDED_ERRMSG then
  if #err > 0 then
    require 'string'
    local m = require 'math'
    print(file_content:subview(m.max(1_isize, chars_parsed-150_isize), chars_parsed))
  end
  ## end
  ## check_and_return_on_error()

  return true, data
end

function TiledMapLoader.apply_map_to_tilemap(
  tm: *Tilemap,
  data: *MapData,
  layer: string,
  tile_callback: function(x: integer, y: integer, i: isize, tile: integer)
): boolean
  local ok, layer_data = find_named_layer(layer, &data.tile_layers)
  
  if ok then
    tm.tilemap_width = layer_data.width
    tm.map:reserve(#layer_data.data)
    for i = 0, < #layer_data.data do
      local tile = layer_data.data[i] + 1
      tm.map:push(tile)
      if tile > 0 and tile_callback then
        local x = i % layer_data.width
        local y = i // layer_data.width
        tile_callback(x, y, i, tile)
      end
    end
    return true
  end

  return false
end

function TiledMapLoader.callbacks_per_object(
  tm: *Tilemap,
  data: *MapData,
  layer: string,
  callbacks_by_class: hashmap(string, function(ObjectData)),
  callbacks_by_name: hashmap(string, function(ObjectData))
): boolean
  local ok, layer_data = find_named_layer(layer, &data.object_layers)
  check(ok, "layer not found")

  if ok then
    for _, obj in mipairs(layer_data.objects) do
      local ok, callback = callbacks_by_class:has_and_get(obj.class_name)
      if ok then
        callback($obj)
      end

      local ok, callback = callbacks_by_name:has_and_get(obj.name)
      if ok then
        callback($obj)
      end
    end
    return true
  end

  return false
end

local TiledMapLoader.TileLayerData = @TileLayerData
local TiledMapLoader.ObjectData = @ObjectData
local TiledMapLoader.ObjectLayerData = @ObjectLayerData
local TiledMapLoader.MapData = @MapData

return TiledMapLoader
