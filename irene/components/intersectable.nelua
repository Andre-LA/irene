require 'span'
require 'math'
require 'nene.math'
require 'irene.makers'

local Vec2, Rectf = @Math.Vec2, @Math.Rectf
local Comps = @Irene.Comps

local Intersectable = @record{
  local_rect: Rectf,
  global_rect: Rectf,
  mask: uint32,
}
## Irene.impl_is_component(Intersectable, true)

global Comps.Intersectable = @Intersectable

function Intersectable.rect_from_vertices(vertices: span(Vec2)): Rectf
  local min_x, min_y, max_x, max_y = 0.0, 0.0, 0.0, 0.0

  for i = 0, < #vertices do
    min_x = math.min(vertices[i].x, min_x)
    max_x = math.max(vertices[i].x, max_x)

    min_y = math.min(vertices[i].y, min_y)
    max_y = math.max(vertices[i].y, max_y)
  end

  return (@Rectf){
    min_x, min_y,
    max_x, max_y
  }
end

function Intersectable.get_global_rect(rect: Rectf, pos: Vec2): Rectf
  rect.x = rect.x + pos.x
  rect.y = rect.y + pos.y
  return rect
end

function Intersectable:set_global_rect(pos: Vec2)
  self.global_rect = Intersectable.get_global_rect(self.local_rect, pos)
end

function Intersectable:set_rects(pos: Vec2, vertices: span(Vec2))
  self.local_rect = Intersectable.rect_from_vertices(vertices)
  self:set_global_rect(pos)
end

function Intersectable:is_intersecting(other: overload(*Intersectable, *Rectf, Vec2)): boolean
  ## if other.type.is_pointer then -- can be an Intersectable or Rectf
    local other_rect: Rectf = {}

    ## if other.type.subtype.is_intersectable then -- is an Intersectable
      other_rect = other.global_rect
    ## else -- is a Rectf
      other_rect = other
    ## end

    return self.global_rect:is_intersecting(other_rect)
  ## else -- is Vec2
    return self.global_rect:is_intersecting(other)
  ## end
end

function Intersectable:get_intersection(other_intersectable: *Intersectable): (Rectf, boolean)
  local intersection, is_intersecting = self.global_rect:get_intersection(other_intersectable.global_rect)
  return intersection, is_intersecting
end

function Intersectable:init(pos: Vec2, vertices: span(Vec2))
  self:set_rects(pos, vertices)
end
