-- Collider component

--[[
  Copyright (c) 2020-2022 Andr√© Luiz Alvares

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at https://mozilla.org/MPL/2.0/.

  SPDX-License-Identifier: MPL-2.0
]]

local math = require 'math'

local Rect = require 'nene.math.rect'
local Vec2 = require 'nene.math.vec2'

local component = require 'rotor.component'
local storage = require 'rotor.storage'
local GenIdx = require 'rotor.gen_idx'

local EntityData = require 'irene.components.entity_data'

local Collider = @component(@record{
  active: boolean,         -- active field, set this to true to make it in the collision system
  hitbox: Rect,            -- collider's hitbox
  collision_mask: uint32,  -- bitmask of all collider ids this collider can collide with!
  with_collision: boolean, -- if true, this collider will "physically" collide with other colliders, that is, will get it's velocity interrupted.
  corner_tolerance: integer,   -- this adds a bit of tolerance, useful to avoid unwanted collision on corners
  velocity_interrupted: Vec2,  -- used internally by the collision system
  intersecting_with: storage(EntityData, 8), -- stores the data of the entities from the on going collisions

  -- these fields are actually defined, but later in this source file, through meta-programming:
  -- on_collision: function(self: *Collider, other: *Collider, self_data: *EntityData, other_data: *EntityData)       -- general reaction callback, continuously called per frame while the collider is intersecting other collider
  -- on_begin_collision: function(self: *Collider, other: *Collider, self_data: *EntityData, other_data: *EntityData) -- begin reaction callback, called when the collider begin intersecting another one
  -- on_end_collision: function(self: *Collider, other: *Collider, self_data: *EntityData, other_data: *EntityData)   -- end reaction callback, called when the collider stops intersecting another collider
})

local callback_t = @function(self: *Collider, other: *Collider, self_data: *EntityData, other_data: *EntityData)
## Collider.value:add_field('on_collision', callback_t.value)
## Collider.value:add_field('on_begin_collision', callback_t.value)
## Collider.value:add_field('on_end_collision', callback_t.value)

local Collider.CollisionCallback = callback_t

function Collider:was_already_intersecting_with(id: GenIdx): (boolean, GenIdx)
  for idx, iw in mpairs(self.intersecting_with) do
    if iw.id == id then
      return true, GenIdx{ idx, self.intersecting_with.generations[idx] }
    end
  end

  return false
end

function Collider:final_hitbox(pos: Vec2): Rect
  local final_hitbox: Rect = {
    x = self.hitbox.x + math.ifloor(pos.x),
    y = self.hitbox.y + math.ifloor(pos.y),
    w = self.hitbox.w,
    h = self.hitbox.h,
  }
  return final_hitbox
end

function Collider:get_intersection(self_pos: Vec2, other: Collider, other_pos: Vec2): (Rect, boolean)
  local self_hitbox = self:final_hitbox(self_pos)
  local other_hitbox = other:final_hitbox(other_pos)
  return self_hitbox:get_intersection(other_hitbox)
end

function Collider:simple_collision(self_pos: Vec2, other: Collider, other_pos: Vec2): (boolean, Rect, Rect)
  local self_hitbox = self:final_hitbox(self_pos)
  local other_hitbox = other:final_hitbox(other_pos)
  return self_hitbox:simple_collision(other_hitbox)
end

return Collider
