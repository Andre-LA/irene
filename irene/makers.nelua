## local tabler = require 'nelua.utils.tabler'
## local metalib = require 'irene.metalib'

require 'irene.core'

## if PROF then
  require 'nprof'
  global nprof: NProf = {}
## end

##[[
  local function is_record(_type)
    return metalib.basic_typecheck(_type, 'record', function(value)
      if _type and _type.value and traits.is_type(_type.value) and _type.value.is_record then
        return true
      else
        tostring(_type)
      end
    end)
  end

  local function gen_errmsg(comp_type, err_msg)
    local comp_name = comp_type.name, metalib.pascalcase_to_snakecase(comp_type.name)
    return string.format(
      'assertion error with type %s: %s. Maybe you forgot to use ## Irene.is_component(%s)?',
      comp_name,
      err_msg,
      comp_name
    )
  end

  local function assert_type_is_component(comp_type)
    staticassert(is_record(comp_type))

    local c_type, err_msg = metalib.basic_typecheck(comp_type.value, "record with 'is_component' trait", function(value)
      local is_type = traits.is_type(value)
      local is_record = is_type and value.is_record
      local is_component = is_record and value.is_component

      if is_component then
        return true
      elseif is_record then
        return "record without 'is_component' trait"
      else
        return tostring(value)
      end
    end)

    staticassert(c_type, gen_errmsg(comp_type, err_msg)) -- does assertion failure when ## Irene.impl_is_component wasn't used

    return comp_type
  end
]]

-- [[ mark record as component [[

-- this macro auto-implements the Irene.impl_is_component trait
## function Irene.impl_is_component(R, use_self_ids)
  ##[[
  -- ensure that a record is passed
  staticassert(is_record(R))

  local r_name = R.value.is_entity and R.value.metainfo.name or R.name
  local R_snakecased_name = metalib.pascalcase_to_snakecase(r_name)

  -- mark the Irene.impl_is_component trait
  R.value.is_component = true
  -- mark component-specific trait
  R.value["is_"..R_snakecased_name] = true

  -- add meta information
  if not R.value.metainfo then R.value.metainfo = {} end
  R.value.metainfo.snake_name = R_snakecased_name
  R.value.metainfo.use_self_ids = use_self_ids

  -- macro do add the mask and the storage of this component
  Irene.add_mask_and_storage(R_snakecased_name, R)

  -- if use_self_ids is true, add self_id and entity_id fields, of type GenerationalIndex
  if use_self_ids then
    R.value:add_field('self_id', GenerationalIndex.value)
    R.value:add_field('entity_id', GenerationalIndex.value)
  end
  ]]

  local R: type = @#[R]#

  function R.get_entry_from_id(id: GenerationalIndex): optional(*R)
    return Irene.storages.#|R_snakecased_name|#:get_entry(id)
  end

  function R.get_entry_from_entity_id(id: GenerationalIndex): optional(*R)
    local result: optional(*R) = {}

    local entity_opt = Irene.storages.entity:get_entry(id)

    if entity_opt.filled then
      local entity = entity_opt:get()
      local r_storage_index_opt = entity:get_storage_index(Irene.masks.#|R_snakecased_name|#)
      if r_storage_index_opt.filled then
        local r_storage_index = r_storage_index_opt:get()

        local entity_r_id = entity.associated_components[r_storage_index]

        local entity_r_opt = R.get_entry_from_id(entity_r_id)
        if entity_r_opt.filled then
          result:set(entity_r_opt:get())
        end
      end
    end

    return result
  end
## end
-- ]] mark record as component ]]

-- [[ Entity maker [[
## local n = {'st', 'nd', 'rd'}
## local function nth(i) return i < 4 and i..n[i] or i..'th' end

## local make_entity = generalize(function(entity_name, ...)
  ##[[
  -- TODO: also should asserts if the first character is a number
  staticassert(not string.find(entity_name, '[^_%w]'), 'entity name must contains only alphanumeric and/or underscores')

  local entity_shape = {...}
  local components, children = {}, {}

  local subnickname = table.concat(
    tabler.imap(entity_shape, function(v) return v.nickname end),
    ', '
  )

  local nickname = "entity('"..entity_name.."', "..subnickname..")"
  local codename = 'rotor_quick_'..entity_name
  ]]

  local EntityT <nickname #[nickname]#, codename #[codename]#> = @record{
    -- more added below
  }

  ##[[
  EntityT.value.is_entity = true
  if not EntityT.value.metainfo then EntityT.value.metainfo = {} end
  EntityT.value.metainfo.name = entity_name
  Irene.impl_is_component(EntityT, true)
  ]]

  function EntityT:get_entity(): *Entity
    local entity_opt = Irene.storages.entity:get_entry(self.entity_id)
    assert(entity_opt.filled, #["Could not get " .. entity_name .. "'s entity"]#)
    return entity_opt:get()
  end

  local EntityInitValues = @record{--[[ more added below ]]}
  local EntityOnDestroyCallbacks = @record{--[[ more added below ]]}

  ##[[
  -- collect entities and components
  for i = 1, #entity_shape do
    -- ensures that there are only components or entities in entity_shape
    local msg_nth = 'error on '..nth(i)..' parameter: '
    staticassert(entity_shape[i].is_component or entity_shape[i].is_entity, msg_nth..'is neither component or entity')

    if entity_shape[i].is_component then
      table.insert(components, entity_shape[i])
    end
    if entity_shape[i].is_entity then
      table.insert(children, entity_shape[i])
    end
  end

  table.insert(components, EntityT.value)
  ]]

  -- add fields and functions to EntityT for each component
  -- it also configures EntityInitValues
  ## for i, comp in ipairs(components) do
    ##[[
    local comp_scname = comp.metainfo.snake_name

    -- add the corresponding id field
    EntityT.value:add_field(comp_scname..'_id', GenerationalIndex.value)

    -- add the component-only init field
    if not comp.is_entity then
      EntityInitValues.value:add_field(comp_scname, comp)
    end
    ]]

    -- add the on destroy callback field
    local CallbackType: type = @function(comp_ref: pointer(#[comp]#))
    ## EntityOnDestroyCallbacks.value:add_field(comp_scname, CallbackType.value)
  ## end

  function EntityT:try_get_component(component: type): optional(pointer(#[component.value]#))
    ##[[
    local fn_name = EntityT.value.nickname..'.try_get_component'
    staticassert(component.value.is_component, fn_name..': type "'..component.value.nickname..'" is not a component')

    local comp_scname = component.value.metainfo.snake_name
    local comp_idname = comp_scname..'_id'
    ]]

    return Irene.storages.#|comp_scname|#:get_entry(self.#|comp_idname|#)
  end

  function EntityT:get_component(component: type): pointer(#[component.value]#)
    ##[[
    local fn_name = EntityT.value.nickname..'.get_component'
    staticassert(component.value.is_component, fn_name..': type "'..component.value.nickname..'" is not a component')

    local comp_scname = component.value.metainfo.snake_name
    local comp_idname = comp_scname..'_id'
    ]]

    local comp_opt = self:try_get_component(component)
    assert(comp_opt.filled, #[fn_name..': '..comp_scname..' is not associated with entity']#)

    return comp_opt:get()
  end

  -- add fields and functions to EntityT for each child entity
  -- add the child type to EntityInitValues
  ##[[
  for i, child in ipairs(children) do
    local child_name = child.metainfo.name
    EntityT.value:add_field(child_name, child)
    EntityInitValues.value:add_field(child_name, EntityT.value.fields[child_name].type)
  end
  ]]

  function EntityT:get_child(child: type): (#[child.value]#, *Entity)
    ##[[
    local fn_name = EntityT.value.nickname..'.get_child'
    staticassert(child.value.is_component, fn_name..': type "'..child.value.nickname..'" is not an entity')
    local child_name = child.type.metainfo.name
    ]]

    local child_value = self.#|child_name|#
    local child_entity = child_value:get_entity()

    return child_value, child_entity
  end

  function EntityT.new(initial_values: EntityInitValues): (EntityT, *Entity)
    local result: EntityT = {}

    -- create an entity entry
    local entity_id, entity = Irene.storages.entity:new_entry(Entity.new())
    result.entity_id = entity_id

    -- children are already created, so it should be just copied
    ## for i, child in ipairs(children) do
      ## local child_name = child.metainfo.name
      result.#|child_name|# = initial_values.#|child_name|#
    ## end

    -- create and associate each component
    ## for i, comp in ipairs(table.move(components, 1, #components - 1, 1, {})) do
      ## if not comp.metainfo.name or comp.metainfo.name ~= entity_name then
        ## local comp_scname = comp.metainfo.snake_name
        ## local c_id = comp_scname..'_id'

        local #|c_id|#, #|comp_scname|# = Irene.storages.#|comp_scname|#:new_entry(initial_values.#|comp_scname|#)
        entity:associate(#|c_id|#, Irene.masks.#|comp_scname|#)

        ## if comp.metainfo.use_self_ids then
          #|comp_scname|#.self_id = #|c_id|#
          #|comp_scname|#.entity_id = entity_id
        ## end

        result.#|c_id|# = #|c_id|#
      ## end
    ## end

    ##[[
    local entityT_comp = components[#components]
    local entityT_comp_name = entityT_comp.metainfo.snake_name
    ]]

    local entity_ids_id, entity_ids = Irene.storages.#|entityT_comp_name|#:new_entry(result)
    entity:associate(entity_ids_id, Irene.masks.#|entityT_comp_name|#)

    result.#|entityT_comp_name..'_id'|# = entity_ids_id

    $entity_ids = result

    return result, entity
  end

  function EntityT.destroy(ids: EntityT, callbacks: EntityOnDestroyCallbacks)
    local entity_opt = Irene.storages.entity:get_entry(ids.entity_id)
    if entity_opt.filled then
      local entity = entity_opt:get()

      ## for i, comp in ipairs(components) do
        ## local comp_scname = comp.metainfo.snake_name
        ## local comp_id_name = comp_scname..'_id'

        if callbacks.#|comp_scname|# then
          Irene.storages.#|comp_scname|#:remove_entry(ids.#|comp_id_name|#, callbacks.#|comp_scname|#)
        else
          Irene.storages.#|comp_scname|#:remove_entry(ids.#|comp_id_name|#)
        end
      ## end

      Irene.storages.entity:remove_entry(ids.entity_id, Entity.destroy)
    end
  end

  function EntityT.destroy_from_entity_id(entity_id: GenerationalIndex, callbacks: EntityOnDestroyCallbacks)
    local entity_ids_opt = EntityT.get_entry_from_entity_id(entity_id)

    if entity_ids_opt.filled then
      local entity_ids = entity_ids_opt:get()
      entity_ids:destroy(callbacks)
    end
  end
  ## return EntityT
## end)

global MakeEntity = #[make_entity]#

-- ]] Entity maker ]]

-- [[ system maker [[

## local ins = function(v) return require 'nelua.thirdparty.inspect' (v, {depth = 2}) end

## local make_system = generalize(function(nickname, run_T)
  ##[[
  local component_names = {}
    local component_types = {}

    for _, field in ipairs(run_T.fields) do
      local ftype = field.type
      staticassert(traits.is_type(ftype) and ftype.is_component, 'MakeSystem: type %s is not a component!', ftype)

      table.insert(component_names, field.name)
      table.insert(component_types, ftype)
    end
  ]]

  local optCollectionT = @record{}
  local ptrCollectionT = @record{}

  ## for i, name in ipairs(component_names) do
    local PtrT = @pointer(#[ component_types[i] ]#)
    ## ptrCollectionT.value:add_field(name, PtrT.value)

    local OptT = @optional(PtrT)
    ## optCollectionT.value:add_field(name, OptT.value)
  ## end

  local systemT <nickname #[string.format('system(%s)', nickname)]#> = @record{
    system_data: SystemData
  }

  function systemT.new(): systemT
    local components: vector(BitsetArray) = {}
    components:reserve(#[#component_names]#)

    local new_system: systemT = {}

    ## for _, name in ipairs(component_names) do
      components:push(BitsetArray.copy(Irene.masks.#|name|#))
    ## end

    new_system.system_data = SystemData.new(components)
    return new_system
  end

  function systemT.components_are_available(opts: *optCollectionT): boolean
    local result: boolean = true

    ## for i, name in ipairs(component_names) do
      result = result and opts.#|name|#.filled
    ## end

    return result
  end

  function systemT:update(entity: *Entity)
    self.system_data:update(entity)
  end

  local IterState = @record{
    system_data: *SystemData,
    ids_iterator: function(ids_vec: *vector(vector(GenerationalIndex)), index: isize): (boolean, isize, vector(GenerationalIndex)),
    ids_vec: *vector(vector(GenerationalIndex)),
    index: isize
  }

  function systemT:iterate_components(): (
    function(state: *IterState, index: isize): (boolean, isize, ptrCollectionT),
    IterState,
    isize
  )
    local function iterator(state: *IterState, index: isize): (boolean, isize, ptrCollectionT)
      while state.index < #state.ids_vec do
        local can_iter, index, ids = state.ids_iterator(state.ids_vec, state.index)
        state.index = index

        if can_iter then
          local opts: optCollectionT = {}

          ## for i, field in ipairs(ptrCollectionT.value.fields) do
            ## local component_snakecase_name = field.type.subtype.metainfo.snake_name
            opts.#|field.name|# = Irene.storages.#|component_snakecase_name|#:get_entry( ids[ #[i-1]# ] )
          ## end

          if systemT.components_are_available(opts) then
            local iter_result: ptrCollectionT = {}

            ## for _, field in ipairs(ptrCollectionT.value.fields) do
              iter_result.#|field.name|# = opts.#|field.name|#:get()
            ## end

            return true, index, iter_result
          else
            state.system_data:mark_available(state.index)
          end
        else
          return false, -1, (@ptrCollectionT){}
        end
      end

      return false, -1, (@ptrCollectionT){}
    end

    local ids_iterator, ids_vec, index = self.system_data:iterate_ids()
    return iterator, (@IterState){ system_data = &self.system_data, =ids_iterator, =ids_vec, =index }, -1
  end

  function systemT:destroy()
    self.system_data:destroy()
  end

  ## return systemT
## end)

global MakeSystem = #[make_system]#

-- ]] system maker ]]
