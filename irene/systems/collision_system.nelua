-- Collision system

--[[
  Copyright (c) 2020-2022 Andr√© Luiz Alvares

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at https://mozilla.org/MPL/2.0/.

  SPDX-License-Identifier: MPL-2.0
]]

-- nelua --
local vector = require 'vector'
local math = require 'math'

-- nene --
local Nene = require 'nene'
local Rect = require 'nene.math.rect'
local Vec2 = require 'nene.math.vec2'
local Vec2i = require 'nene.math.vec2i'
local Color = require 'nene.color'

-- rotor --
local GenIdx = require 'rotor.gen_idx'

-- irene --
local Position = require 'irene.components.position'
local Collider = require 'irene.components.collider'
local EntityData = require 'irene.components.entity_data'
local EntitiesRemoved = require 'irene.managers.entities_removed'

-- Collision System --

local Collidable = @record{
  position: *Position,
  collider: *Collider,
  entity_data: *EntityData,
}

function Collidable:to_collided_data(): Collider.CollidedData
  check(self.collider, 'no initialized collider')
  check(self.entity_data, 'no initialized entity data')

  local hitbox = self.collider:final_hitbox(self.position:final_pos())
  return Collider.CollidedData.init(self.collider, self.entity_data, hitbox)
end

function Collidable:try_call_callback(other_collidable: *Collidable, callback_name: string <comptime>): boolean
  ##[[
  local valid_callbacks = { on_intersection = true, on_begin_intersection = true, on_end_intersection = true }
  static_assert(valid_callbacks[callback_name.value], "tried to call an unexpected callback '%s'", callback_name.value)
  ]]

  if self.collider.#|callback_name.value|# then
    local collision_data = Collider.CollisionData.init(self:to_collided_data(), other_collidable:to_collided_data())
    self.collider.#|callback_name.value|#(collision_data)
    return true
  end

  return false
end

function Collidable:apply_physical_collision(pos: Vec2, resolved_hitbox: Rect)
  local resolved_pos: Vec2i = { resolved_hitbox.x, resolved_hitbox.y }
  local hitbox_pos: Vec2i = { self.collider.hitbox.x,  self.collider.hitbox.y }

  local ipos: Vec2i
  ipos.x = math.ifloor(pos.x)
  ipos.y = math.ifloor(pos.y)

  local diff = resolved_pos - hitbox_pos - ipos

  if diff.x ~= 0 then
    self.position.local_pos.x = self.position.local_pos.x + diff.x - math.sign(diff.x)
    self.collider.velocity_interrupted.x = math.sign(diff.x)
  end

  if diff.y ~= 0 then
    self.position.local_pos.y = self.position.local_pos.y + diff.y - math.sign(diff.y)
    self.collider.velocity_interrupted.y = math.sign(-diff.y)
  end
end

local CollisionSystem = @record{
  collidables: vector(Collidable),
  draw_collisions: boolean,
}

function CollisionSystem:run(c: Collidable)
  c.collider.velocity_interrupted.x = 0
  c.collider.velocity_interrupted.y = 0

  self.collidables:push(c)
end

function CollisionSystem:pre_run()
  self.collidables:clear()
end

local function call_end_intersection(intersection_id: GenIdx, self_collidable: *Collidable, other_collidable: *Collidable)
  local ok = self_collidable.collider.intersecting_with:mget(intersection_id)
  self_collidable.collider.intersecting_with:remove(intersection_id)

  self_collidable:try_call_callback(other_collidable, 'on_end_intersection')
end

function CollisionSystem:post_run()
  local function draw_collidable(nene: *Nene, collidable: Collidable, color: Color)
    local pos = collidable.position:final_pos()
    local hitbox = collidable.collider.hitbox

    hitbox.x, hitbox.y = hitbox.x + math.ifloor(pos.x), hitbox.y + math.ifloor(pos.y)

    nene:render_draw_rect(hitbox, true, color)
  end

  local nene = Nene.instance()

  for i = 0, < #self.collidables do
    local i_collidable = self.collidables[i]

    -- ignore if the collider isn't active
    if not i_collidable.collider.active then
      continue
    end

    -- remove removed entities from intersecting_with
    for idx, iw in mpairs(i_collidable.collider.intersecting_with) do
      local gen_id = GenIdx{ idx, i_collidable.collider.intersecting_with.generations[idx] }

      if EntitiesRemoved.try_find_entity(iw.id, iw.mask) then
        i_collidable.collider.intersecting_with:remove(gen_id)
      end
    end

    -- iterate over other colliders of the game (this is unoptimized)
    for j = 0, < #self.collidables do
      -- ignore if j and i refers to the same collider
      if j == i then
        continue
      end

      local j_collidable = self.collidables[j]

      -- ignores if j's collider isn't included on i's intersection mask
      if i_collidable.collider.intersection_mask & j_collidable.entity_data.mask == 0 then
        continue
      end

      local i_pos = i_collidable.position:final_pos()
      local j_pos = j_collidable.position:final_pos()

      local is_intersecting, resolved_hitbox, intersection = i_collidable.collider:simple_collision(i_pos, j_collidable.collider, j_pos)

      if is_intersecting then
        local corner_tolerance = i_collidable.collider.corner_tolerance

        -- ignore if doesn't pass the corner tolerance
        if intersection.w < corner_tolerance and intersection.h < corner_tolerance then
          continue
        end

        -- "physical" collision system
        if i_collidable.collider.collision_mask & j_collidable.entity_data.mask ~= 0 then
          i_collidable:apply_physical_collision(i_pos, resolved_hitbox)
        end

        -- if it isn't a ongoing collision, then call the "begin" callback
        if not (i_collidable.collider:was_already_intersecting_with(j_collidable.entity_data.id)) then
          local ok, id = i_collidable.collider.intersecting_with:push({
            id = j_collidable.entity_data.id,
            mask = j_collidable.entity_data.mask,
          })
          check(ok, "error: failed to push entity id to 'intersecting_with'")

          i_collidable:try_call_callback(j_collidable, 'on_begin_intersection')

          if self.draw_collisions then
            draw_collidable(nene, i_collidable, Color.Palette.blue)
            draw_collidable(nene, j_collidable, Color.Palette.green)
          end
        end

        -- call collision callback
        if i_collidable:try_call_callback(j_collidable, 'on_intersection') and self.draw_collisions then
          draw_collidable(nene, j_collidable, Color.Palette.green)
          draw_collidable(nene, i_collidable, Color.Palette.cyan)
        end
      else
        local was_already_intersecting_with, iw_id = i_collidable.collider:was_already_intersecting_with(j_collidable.entity_data.id)

        if was_already_intersecting_with then -- if it was an on going collision, then call "end" reaction
          call_end_intersection(iw_id, i_collidable, j_collidable)

          if self.draw_collisions then
            draw_collidable(nene, j_collidable, Color.Palette.green)
            draw_collidable(nene, i_collidable, Color.Palette.red)
          end
        end
      end
    end
  end
end

function CollisionSystem:draw_hitboxes()
  local nene = Nene.instance()

  for i = 0, < #self.collidables do
    local col = self.collidables[i]

    local hitbox = col.collider.hitbox
    local pos = col.position:final_pos()

    hitbox.x = math.floor(hitbox.x + pos.x)
    hitbox.y = math.floor(hitbox.y + pos.y)

    nene:render_draw_rect(hitbox, true, Color.Palette.green)
  end
end

return CollisionSystem
